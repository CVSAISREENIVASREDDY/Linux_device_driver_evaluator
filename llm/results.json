{
    "Write a Linux device driver for a simple character device.": [
        {
            "success": true,
            "code": "```c\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\n#define DEVICE_NAME \"simple_char_dev\"\n\nstatic dev_t dev;\nstatic struct cdev cdev;\nstatic struct class *cls;\n\nstatic int simple_char_dev_open(struct inode *inode, struct file *file) {\n    return 0;\n}\n\nstatic int simple_char_dev_release(struct inode *inode, struct file *file) {\n    return 0;\n}\n\nstatic ssize_t simple_char_dev_read(struct file *file, char __user *buf, size_t count, loff_t *ppos) {\n    return 0;\n}\n\nstatic ssize_t simple_char_dev_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos) {\n    return 0;\n}\n\n\nstatic const struct file_operations fops = {\n    .owner = THIS_MODULE,\n    .open = simple_char_dev_open,\n    .release = simple_char_dev_release,\n    .read = simple_char_dev_read,\n    .write = simple_char_dev_write,\n};\n\nstatic int __init simple_char_dev_init(void) {\n    int ret;\n    ret = alloc_chrdev_region(&dev, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        printk(KERN_ERR \"Failed to register char device region\\n\");\n        return ret;\n    }\n\n    cdev_init(&cdev, &fops);\n    ret = cdev_add(&cdev, dev, 1);\n    if (ret < 0) {\n        printk(KERN_ERR \"Failed to add char device\\n\");\n        unregister_chrdev_region(dev, 1);\n        return ret;\n    }\n\n    cls = class_create(THIS_MODULE, DEVICE_NAME);\n    if (IS_ERR(cls)) {\n        printk(KERN_ERR \"Failed to create class\\n\");\n        cdev_del(&cdev);\n        unregister_chrdev_region(dev, 1);\n        return PTR_ERR(cls);\n    }\n\n    device_create(cls, NULL, dev, NULL, DEVICE_NAME);\n\n    return 0;\n}\n\nstatic void __exit simple_char_dev_exit(void) {\n    device_destroy(cls, dev);\n    class_destroy(cls);\n    cdev_del(&cdev);\n    unregister_chrdev_region(dev, 1);\n}\n\nmodule_init(simple_char_dev_init);\nmodule_exit(simple_char_dev_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Bard\");\nMODULE_DESCRIPTION(\"A simple character device driver\");\n```\n",
            "model": "gemini-1.5-flash"
        },
        {
            "success": true,
            "code": "#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n\n#define DEVICE_NAME \"my_char_device\"\n#define MAX_SIZE 256\n\nstatic dev_t char_dev_nr;\nstatic struct class *char_dev_class;\nstatic struct cdev char_dev_cdev;\nstatic char *char_dev_buffer;\nstatic size_t char_dev_buffer_len;\nstatic DEFINE_MUTEX(char_dev_mutex);\n\nstatic int char_dev_open(struct inode *inode, struct file *file)\n{\n\tif (!mutex_trylock(&char_dev_mutex))\n\t\treturn -EBUSY; /* Device is busy */\n\n\t/* No specific per-open data, just acquire the lock for this \"session\" */\n\treturn 0;\n}\n\nstatic int char_dev_release(struct inode *inode, struct file *file)\n{\n\tmutex_unlock(&char_dev_mutex);\n\treturn 0;\n}\n\nstatic ssize_t char_dev_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n\tsize_t bytes_to_read;\n\n\tif (*ppos >= char_dev_buffer_len)\n\t\treturn 0; /* End of file */\n\n\tbytes_to_read = min((size_t)count, char_dev_buffer_len - (size_t)*ppos);\n\n\tif (copy_to_user(buf, char_dev_buffer + *ppos, bytes_to_read))\n\t\treturn -EFAULT;\n\n\t*ppos += bytes_to_read;\n\n\treturn bytes_to_read;\n}\n\nstatic ssize_t char_dev_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tsize_t bytes_to_write;\n\n\tif (*ppos >= MAX_SIZE)\n\t\treturn -ENOSPC; /* No space left on device */\n\n\tbytes_to_write = min((size_t)count, (size_t)MAX_SIZE - (size_t)*ppos);\n\n\tif (copy_from_user(char_dev_buffer + *ppos, buf, bytes_to_write))\n\t\treturn -EFAULT;\n\n\t*ppos += bytes_to_write;\n\tchar_dev_buffer_len = max(char_dev_buffer_len, (size_t)*ppos);\n\n\treturn bytes_to_write;\n}\n\nstatic const struct file_operations char_dev_fops = {\n\t.owner = THIS_MODULE,\n\t.open = char_dev_open,\n\t.release = char_dev_release,\n\t.read = char_dev_read,\n\t.write = char_dev_write,\n\t.llseek = no_llseek,\n};\n\nstatic int __init char_dev_init(void)\n{\n\tint ret;\n\n\tchar_dev_buffer = kmalloc(MAX_SIZE, GFP_KERNEL);\n\tif (!char_dev_buffer)\n\t\treturn -ENOMEM;\n\tchar_dev_buffer_len = 0;\n\n\tret = alloc_chrdev_region(&char_dev_nr, 0, 1, DEVICE_NAME);\n\tif (ret < 0) {\n\t\tpr_err(\"Failed to allocate character device region\\n\");\n\t\tgoto err_free_buffer;\n\t}\n\n\tchar_dev_class = class_create(THIS_MODULE, DEVICE_NAME);\n\tif (IS_ERR(char_dev_class)) {\n\t\tpr_err(\"Failed to create device class\\n\");\n\t\tret = PTR_ERR(char_dev_class);\n\t\tgoto err_unregister_chrdev;\n\t}\n\n\tcdev_init(&char_dev_cdev, &char_dev_fops);\n\tchar_dev_cdev.owner = THIS_MODULE;\n\n\tret = cdev_add(&char_dev_cdev, char_dev_nr, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"Failed to add cdev\\n\");\n\t\tgoto err_destroy_class;\n\t}\n\n\tif (IS_ERR(device_create(char_dev_class, NULL, char_dev_nr, NULL, DEVICE_NAME))) {\n\t\tpr_err(\"Failed to create device\\n\");\n\t\tret = PTR_ERR(char_dev_class);\n\t\tgoto err_del_cdev;\n\t}\n\n\tpr_info(\"Character device '%s' registered with major %d\\n\",\n\t\tDEVICE_NAME, MAJOR(char_dev_nr));\n\n\treturn 0;\n\nerr_del_cdev:\n\tcdev_del(&char_dev_cdev);\nerr_destroy_class:\n\tclass_destroy(char_dev_class);\nerr_unregister_chrdev:\n\tunregister_chrdev_region(char_dev_nr, 1);\nerr_free_buffer:\n\tkfree(char_dev_buffer);\n\n\treturn ret;\n}\n\nstatic void __exit char_dev_exit(void)\n{\n\tdevice_destroy(char_dev_class, char_dev_nr);\n\tclass_destroy(char_dev_class);\n\tcdev_del(&char_dev_cdev);\n\tunregister_chrdev_region(char_dev_nr, 1);\n\tkfree(char_dev_buffer);\n\n\tpr_info(\"Character device '%s' unregistered\\n\", DEVICE_NAME);\n}\n\nmodule_init(char_dev_init);\nmodule_exit(char_dev_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"A simple character device driver\");\nMODULE_VERSION(\"0.1\");",
            "model": "gemini-2.5-flash"
        }
    ],
    "Implement a Linux kernel module that logs messages to the kernel log.": [
        {
            "success": true,
            "code": "```c\n#include <linux/module.h>\n#include <linux/kernel.h>\n\nstatic int __init simple_module_init(void)\n{\n\tpr_info(\"Simple module loaded\\n\");\n\treturn 0;\n}\n\nstatic void __exit simple_module_cleanup(void)\n{\n\tpr_info(\"Simple module unloaded\\n\");\n}\n\nmodule_init(simple_module_init);\nmodule_exit(simple_module_cleanup);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Bard\");\nMODULE_DESCRIPTION(\"A simple kernel module\");\n```\n",
            "model": "gemini-1.5-flash"
        },
        {
            "success": true,
            "code": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n\n/*\n * The module_init() function is called when the module is loaded.\n * The module_exit() function is called when the module is unloaded.\n */\n\nstatic int __init simple_logger_init(void)\n{\n\tpr_info(\"Simple Logger Module: Hello from the kernel!\\n\");\n\treturn 0;\n}\n\nstatic void __exit simple_logger_exit(void)\n{\n\tpr_info(\"Simple Logger Module: Goodbye from the kernel!\\n\");\n}\n\nmodule_init(simple_logger_init);\nmodule_exit(simple_logger_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"A simple kernel module to demonstrate logging.\");\nMODULE_VERSION(\"0.1\");",
            "model": "gemini-2.5-flash"
        }
    ]
}