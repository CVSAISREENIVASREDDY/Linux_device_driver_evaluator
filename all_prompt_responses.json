{
    "Write a Linux kernel driver for a simple device.": {
        "gemini-1.5-flash": {
            "success": true,
            "code": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\n#define DEVICE_NAME \"simple_device\"\n#define MAJOR_NUMBER 240\n\nstatic dev_t dev;\nstatic struct cdev cdev;\nstatic struct class *cls;\n\nstatic int simple_device_open(struct inode *inode, struct file *file) {\n    return 0;\n}\n\nstatic int simple_device_release(struct inode *inode, struct file *file) {\n    return 0;\n}\n\nstatic ssize_t simple_device_read(struct file *file, char __user *buf, size_t count, loff_t *ppos) {\n    return 0;\n}\n\nstatic ssize_t simple_device_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos) {\n    return 0;\n}\n\n\nstatic const struct file_operations simple_device_fops = {\n    .owner = THIS_MODULE,\n    .open = simple_device_open,\n    .release = simple_device_release,\n    .read = simple_device_read,\n    .write = simple_device_write,\n};\n\nstatic int __init simple_device_init(void) {\n    int ret;\n    ret = alloc_chrdev_region(&dev, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        printk(KERN_ERR \"Failed to register char device region\\n\");\n        return ret;\n    }\n\n    cdev_init(&cdev, &simple_device_fops);\n    ret = cdev_add(&cdev, dev, 1);\n    if (ret < 0) {\n        printk(KERN_ERR \"Failed to add char device\\n\");\n        unregister_chrdev_region(dev, 1);\n        return ret;\n    }\n\n    cls = class_create(THIS_MODULE, DEVICE_NAME);\n    if (IS_ERR(cls)) {\n        printk(KERN_ERR \"Failed to create class\\n\");\n        cdev_del(&cdev);\n        unregister_chrdev_region(dev, 1);\n        return PTR_ERR(cls);\n    }\n\n    device_create(cls, NULL, dev, NULL, DEVICE_NAME);\n\n    printk(KERN_INFO \"Simple device initialized\\n\");\n    return 0;\n}\n\nstatic void __exit simple_device_exit(void) {\n    device_destroy(cls, dev);\n    class_destroy(cls);\n    cdev_del(&cdev);\n    unregister_chrdev_region(dev, 1);\n    printk(KERN_INFO \"Simple device removed\\n\");\n}\n\nmodule_init(simple_device_init);\nmodule_exit(simple_device_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Bard\");\nMODULE_DESCRIPTION(\"A simple Linux character device driver\");\nMODULE_VERSION(\"1.0\");\n"
        },
        "gemini-2.5-flash": {
            "success": true,
            "code": "#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/init.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n\n#define DEVICE_NAME \"simple_dev\"\n#define MY_BUF_SIZE 256\n\nstatic dev_t simple_dev_node;\nstatic struct cdev simple_cdev;\nstatic struct class *simple_dev_class;\n\nstatic char simple_dev_buffer[MY_BUF_SIZE];\nstatic int simple_dev_buffer_len;\nstatic DEFINE_MUTEX(simple_dev_mutex);\n\nstatic int simple_dev_open(struct inode *inode, struct file *file)\n{\n    pr_info(\"%s: device opened\\n\", DEVICE_NAME);\n    return 0;\n}\n\nstatic int simple_dev_release(struct inode *inode, struct file *file)\n{\n    pr_info(\"%s: device closed\\n\", DEVICE_NAME);\n    return 0;\n}\n\nstatic ssize_t simple_dev_read(struct file *file, char __user *buf,\n                               size_t count, loff_t *offset)\n{\n    ssize_t bytes_to_read;\n    int ret;\n\n    if (mutex_lock_interruptible(&simple_dev_mutex))\n        return -ERESTARTSYS;\n\n    if (*offset >= simple_dev_buffer_len) {\n        bytes_to_read = 0;\n        goto out;\n    }\n\n    bytes_to_read = min((ssize_t)(simple_dev_buffer_len - *offset), count);\n\n    ret = copy_to_user(buf, simple_dev_buffer + *offset, bytes_to_read);\n    if (ret == bytes_to_read) {\n        bytes_to_read = -EFAULT;\n        goto out;\n    }\n\n    *offset += bytes_to_read;\n    pr_info(\"%s: read %zd bytes\\n\", DEVICE_NAME, bytes_to_read);\n\nout:\n    mutex_unlock(&simple_dev_mutex);\n    return bytes_to_read;\n}\n\nstatic ssize_t simple_dev_write(struct file *file, const char __user *buf,\n                                size_t count, loff_t *offset)\n{\n    ssize_t bytes_to_write;\n    int ret;\n\n    if (mutex_lock_interruptible(&simple_dev_mutex))\n        return -ERESTARTSYS;\n\n    if (*offset >= MY_BUF_SIZE) {\n        bytes_to_write = 0;\n        goto out;\n    }\n\n    bytes_to_write = min((ssize_t)(MY_BUF_SIZE - *offset), count);\n\n    ret = copy_from_user(simple_dev_buffer + *offset, buf, bytes_to_write);\n    if (ret == bytes_to_write) {\n        bytes_to_write = -EFAULT;\n        goto out;\n    }\n\n    *offset += bytes_to_write;\n    if (*offset > simple_dev_buffer_len)\n        simple_dev_buffer_len = *offset;\n\n    pr_info(\"%s: wrote %zd bytes, current len %d\\n\",\n            DEVICE_NAME, bytes_to_write, simple_dev_buffer_len);\n\nout:\n    mutex_unlock(&simple_dev_mutex);\n    return bytes_to_write;\n}\n\nstatic const struct file_operations simple_dev_fops = {\n    .owner = THIS_MODULE,\n    .open = simple_dev_open,\n    .release = simple_dev_release,\n    .read = simple_dev_read,\n    .write = simple_dev_write,\n    .llseek = no_llseek,\n};\n\nstatic int __init simple_driver_init(void)\n{\n    int ret;\n    struct device *dev_device;\n\n    pr_info(\"%s: initializing module\\n\", DEVICE_NAME);\n\n    ret = alloc_chrdev_region(&simple_dev_node, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        pr_err(\"%s: failed to allocate char device region\\n\", DEVICE_NAME);\n        return ret;\n    }\n\n    cdev_init(&simple_cdev, &simple_dev_fops);\n    simple_cdev.owner = THIS_MODULE;\n\n    ret = cdev_add(&simple_cdev, simple_dev_node, 1);\n    if (ret < 0) {\n        pr_err(\"%s: failed to add cdev\\n\", DEVICE_NAME);\n        goto err_unregister_chrdev;\n    }\n\n    simple_dev_class = class_create(THIS_MODULE, DEVICE_NAME);\n    if (IS_ERR(simple_dev_class)) {\n        pr_err(\"%s: failed to create device class\\n\", DEVICE_NAME);\n        ret = PTR_ERR(simple_dev_class);\n        goto err_del_cdev;\n    }\n\n    dev_device = device_create(simple_dev_class, NULL, simple_dev_node, NULL,\n                               DEVICE_NAME);\n    if (IS_ERR(dev_device)) {\n        pr_err(\"%s: failed to create device\\n\", DEVICE_NAME);\n        ret = PTR_ERR(dev_device);\n        goto err_destroy_class;\n    }\n\n    simple_dev_buffer_len = 0;\n    pr_info(\"%s: module initialized successfully (Major: %d, Minor: %d)\\n\",\n            DEVICE_NAME, MAJOR(simple_dev_node), MINOR(simple_dev_node));\n\n    return 0;\n\nerr_destroy_class:\n    class_destroy(simple_dev_class);\nerr_del_cdev:\n    cdev_del(&simple_cdev);\nerr_unregister_chrdev:\n    unregister_chrdev_region(simple_dev_node, 1);\n    return ret;\n}\n\nstatic void __exit simple_driver_exit(void)\n{\n    pr_info(\"%s: exiting module\\n\", DEVICE_NAME);\n\n    device_destroy(simple_dev_class, simple_dev_node);\n    class_destroy(simple_dev_class);\n    cdev_del(&simple_cdev);\n    unregister_chrdev_region(simple_dev_node, 1);\n\n    pr_info(\"%s: module unloaded\\n\", DEVICE_NAME);\n}\n\nmodule_init(simple_driver_init);\nmodule_exit(simple_driver_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"A simple character device driver\");\nMODULE_VERSION(\"0.1\");"
        }
    },
    "2Implement a character device driver with basic read/write operations.": {
        "gemini-1.5-flash": {
            "success": true,
            "code": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/uaccess.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n\n#define DEVICE_NAME \"chardev\"\n#define MAX_BUF_SIZE 1024\n\nstatic int major_num;\nstatic dev_t dev;\nstatic struct cdev chardev;\nstatic struct class *chardev_class;\nstatic char *buffer;\n\n\nstatic int chardev_open(struct inode *inode, struct file *filp) {\n    return 0;\n}\n\nstatic int chardev_release(struct inode *inode, struct file *filp) {\n    return 0;\n}\n\nstatic ssize_t chardev_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos) {\n    size_t bytes_to_read = min(count, MAX_BUF_SIZE - *f_pos);\n    if (bytes_to_read == 0) return 0;\n    if (copy_to_user(buf, buffer + *f_pos, bytes_to_read))\n        return -EFAULT;\n    *f_pos += bytes_to_read;\n    return bytes_to_read;\n}\n\nstatic ssize_t chardev_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos) {\n    size_t bytes_to_write = min(count, MAX_BUF_SIZE - *f_pos);\n    if (bytes_to_write == 0) return 0;\n    if (copy_from_user(buffer + *f_pos, buf, bytes_to_write))\n        return -EFAULT;\n    *f_pos += bytes_to_write;\n    return bytes_to_write;\n}\n\nstatic const struct file_operations chardev_fops = {\n    .owner = THIS_MODULE,\n    .open = chardev_open,\n    .release = chardev_release,\n    .read = chardev_read,\n    .write = chardev_write,\n};\n\nstatic int __init chardev_init(void) {\n    int ret;\n    \n    buffer = kmalloc(MAX_BUF_SIZE, GFP_KERNEL);\n    if (!buffer) return -ENOMEM;\n\n    ret = alloc_chrdev_region(&dev, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        printk(KERN_ERR \"Failed to allocate major number\\n\");\n        goto err_alloc_chrdev;\n    }\n    major_num = MAJOR(dev);\n\n    cdev_init(&chardev, &chardev_fops);\n    ret = cdev_add(&chardev, dev, 1);\n    if (ret < 0) {\n        printk(KERN_ERR \"Failed to add character device\\n\");\n        goto err_cdev_add;\n    }\n\n    chardev_class = class_create(THIS_MODULE, DEVICE_NAME);\n    if (IS_ERR(chardev_class)) {\n        ret = PTR_ERR(chardev_class);\n        goto err_class_create;\n    }\n    device_create(chardev_class, NULL, dev, NULL, DEVICE_NAME);\n\n    printk(KERN_INFO \"Character device registered with major number %d\\n\", major_num);\n    return 0;\n\nerr_class_create:\n    cdev_del(&chardev);\nerr_cdev_add:\n    unregister_chrdev_region(dev, 1);\nerr_alloc_chrdev:\n    kfree(buffer);\n    return ret;\n}\n\nstatic void __exit chardev_exit(void) {\n    device_destroy(chardev_class, dev);\n    class_unregister(chardev_class);\n    class_destroy(chardev_class);\n    cdev_del(&chardev);\n    unregister_chrdev_region(dev, 1);\n    kfree(buffer);\n    printk(KERN_INFO \"Character device unregistered\\n\");\n}\n\nmodule_init(chardev_init);\nmodule_exit(chardev_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Bard\");\nMODULE_DESCRIPTION(\"A simple character device driver\");\n"
        },
        "gemini-2.5-flash": {
            "success": true,
            "code": "#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n\n#define DEVICE_NAME \"mychardev\"\n#define CLASS_NAME  \"mychardev_class\"\n#define BUFFER_SIZE 1024\n\nstatic dev_t major_dev_num;\nstatic struct class* my_char_device_class = NULL;\n\nstruct my_char_device {\n    struct cdev cdev;\n    char buffer[BUFFER_SIZE];\n    size_t buffer_len;\n    struct mutex mutex;\n};\n\nstatic struct my_char_device *my_device;\n\nstatic int my_chardev_open(struct inode *inode, struct file *file)\n{\n    struct my_char_device *dev = container_of(inode->i_cdev, struct my_char_device, cdev);\n    file->private_data = dev;\n    pr_info(\"%s: Device opened successfully.\\n\", DEVICE_NAME);\n    return 0;\n}\n\nstatic int my_chardev_release(struct inode *inode, struct file *file)\n{\n    pr_info(\"%s: Device closed.\\n\", DEVICE_NAME);\n    return 0;\n}\n\nstatic ssize_t my_chardev_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\n{\n    struct my_char_device *dev = (struct my_char_device *)file->private_data;\n    ssize_t bytes_to_read;\n    int ret;\n\n    if (mutex_lock_interruptible(&dev->mutex))\n        return -ERESTARTSYS;\n\n    bytes_to_read = dev->buffer_len - *pos;\n    if (bytes_to_read > count) {\n        bytes_to_read = count;\n    }\n    if (bytes_to_read <= 0) {\n        mutex_unlock(&dev->mutex);\n        return 0;\n    }\n\n    ret = copy_to_user(buf, dev->buffer + *pos, bytes_to_read);\n    if (ret) {\n        pr_err(\"%s: Failed to copy %d bytes to user space (copied %d).\\n\", DEVICE_NAME, (int)bytes_to_read, (int)(bytes_to_read - ret));\n        mutex_unlock(&dev->mutex);\n        return -EFAULT;\n    }\n\n    *pos += bytes_to_read;\n    pr_info(\"%s: Read %zd bytes from device.\\n\", DEVICE_NAME, bytes_to_read);\n\n    mutex_unlock(&dev->mutex);\n    return bytes_to_read;\n}\n\nstatic ssize_t my_chardev_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)\n{\n    struct my_char_device *dev = (struct my_char_device *)file->private_data;\n    ssize_t bytes_to_write;\n    int ret;\n\n    if (mutex_lock_interruptible(&dev->mutex))\n        return -ERESTARTSYS;\n\n    if (*pos >= BUFFER_SIZE) {\n        mutex_unlock(&dev->mutex);\n        return -ENOSPC;\n    }\n\n    bytes_to_write = BUFFER_SIZE - *pos;\n    if (bytes_to_write > count) {\n        bytes_to_write = count;\n    }\n    if (bytes_to_write <= 0) {\n        mutex_unlock(&dev->mutex);\n        return 0;\n    }\n\n    ret = copy_from_user(dev->buffer + *pos, buf, bytes_to_write);\n    if (ret) {\n        pr_err(\"%s: Failed to copy %d bytes from user space (copied %d).\\n\", DEVICE_NAME, (int)bytes_to_write, (int)(bytes_to_write - ret));\n        mutex_unlock(&dev->mutex);\n        return -EFAULT;\n    }\n\n    *pos += bytes_to_write;\n    if (*pos > dev->buffer_len) {\n        dev->buffer_len = *pos;\n    }\n\n    pr_info(\"%s: Written %zd bytes to device. Current buffer length: %zu\\n\", DEVICE_NAME, bytes_to_write, dev->buffer_len);\n\n    mutex_unlock(&dev->mutex);\n    return bytes_to_write;\n}\n\nstatic const struct file_operations my_chardev_fops = {\n    .owner   = THIS_MODULE,\n    .open    = my_chardev_open,\n    .release = my_chardev_release,\n    .read    = my_chardev_read,\n    .write   = my_chardev_write,\n    .llseek  = no_llseek,\n};\n\nstatic int __init my_chardev_init(void)\n{\n    int ret;\n    struct device *dev_node;\n\n    pr_info(\"%s: Initializing the character device module.\\n\", DEVICE_NAME);\n\n    ret = alloc_chrdev_region(&major_dev_num, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        pr_err(\"%s: Failed to allocate character device region. Error: %d\\n\", DEVICE_NAME, ret);\n        return ret;\n    }\n    pr_info(\"%s: Device numbers allocated. Major: %d, Minor: %d\\n\", DEVICE_NAME, MAJOR(major_dev_num), MINOR(major_dev_num));\n\n    my_device = kmalloc(sizeof(struct my_char_device), GFP_KERNEL);\n    if (!my_device) {\n        pr_err(\"%s: Failed to allocate memory for my_char_device.\\n\", DEVICE_NAME);\n        ret = -ENOMEM;\n        goto err_unregister_chrdev;\n    }\n\n    memset(my_device->buffer, 0, BUFFER_SIZE);\n    my_device->buffer_len = 0;\n    mutex_init(&my_device->mutex);\n\n    cdev_init(&my_device->cdev, &my_chardev_fops);\n    my_device->cdev.owner = THIS_MODULE;\n\n    ret = cdev_add(&my_device->cdev, major_dev_num, 1);\n    if (ret < 0) {\n        pr_err(\"%s: Failed to add cdev. Error: %d\\n\", DEVICE_NAME, ret);\n        goto err_free_dev_mem;\n    }\n\n    my_char_device_class = class_create(CLASS_NAME);\n    if (IS_ERR(my_char_device_class)) {\n        pr_err(\"%s: Failed to create device class.\\n\", DEVICE_NAME);\n        ret = PTR_ERR(my_char_device_class);\n        goto err_del_cdev;\n    }\n\n    dev_node = device_create(my_char_device_class, NULL, major_dev_num, NULL, DEVICE_NAME);\n    if (IS_ERR(dev_node)) {\n        pr_err(\"%s: Failed to create device node.\\n\", DEVICE_NAME);\n        ret = PTR_ERR(dev_node);\n        goto err_destroy_class;\n    }\n\n    pr_info(\"%s: Module loaded and device created successfully.\\n\", DEVICE_NAME);\n    return 0;\n\nerr_destroy_class:\n    class_destroy(my_char_device_class);\nerr_del_cdev:\n    cdev_del(&my_device->cdev);\nerr_free_dev_mem:\n    kfree(my_device);\nerr_unregister_chrdev:\n    unregister_chrdev_region(major_dev_num, 1);\n    return ret;\n}\n\nstatic void __exit my_chardev_exit(void)\n{\n    pr_info(\"%s: Exiting the character device module.\\n\", DEVICE_NAME);\n\n    device_destroy(my_char_device_class, major_dev_num);\n    class_destroy(my_char_device_class);\n    cdev_del(&my_device->cdev);\n    kfree(my_device);\n    unregister_chrdev_region(major_dev_num, 1);\n\n    pr_info(\"%s: Module unloaded.\\n\", DEVICE_NAME);\n}\n\nmodule_init(my_chardev_init);\nmodule_exit(my_chardev_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name/Company\");\nMODULE_DESCRIPTION(\"A simple character device driver with read/write.\");\nMODULE_VERSION(\"0.1\");"
        }
    },
    "Create a kernel module that interacts with hardware.": {
        "gemini-1.5-flash": {
            "success": true,
            "code": "```c\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n\n#define DEVICE_NAME \"my_hardware\"\n#define MAJOR_NUM 240\n\nstatic dev_t dev;\nstatic struct cdev cdev;\nstatic struct class *cls;\nstatic void __iomem *hw_addr;\n\nstatic int my_hardware_open(struct inode *inode, struct file *file)\n{\n    return 0;\n}\n\nstatic int my_hardware_release(struct inode *inode, struct file *file)\n{\n    return 0;\n}\n\nstatic ssize_t my_hardware_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n    unsigned long val = ioread32(hw_addr);\n    if (copy_to_user(buf, &val, sizeof(val)))\n        return -EFAULT;\n    return sizeof(val);\n\n}\n\nstatic ssize_t my_hardware_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n    unsigned long val;\n    if (copy_from_user(&val, buf, sizeof(val)))\n        return -EFAULT;\n    iowrite32(val, hw_addr);\n    return count;\n}\n\nstatic const struct file_operations my_hardware_fops = {\n    .owner = THIS_MODULE,\n    .open = my_hardware_open,\n    .release = my_hardware_release,\n    .read = my_hardware_read,\n    .write = my_hardware_write,\n};\n\n\nstatic int __init my_hardware_init(void)\n{\n    int ret;\n    \n    if (alloc_chrdev_region(&dev, 0, 1, DEVICE_NAME) < 0) {\n        printk(KERN_ERR \"Failed to allocate char device region\\n\");\n        return -1;\n    }\n    \n    cdev_init(&cdev, &my_hardware_fops);\n    \n    if (cdev_add(&cdev, dev, 1) < 0) {\n        printk(KERN_ERR \"Failed to add char device\\n\");\n        unregister_chrdev_region(dev, 1);\n        return -1;\n    }\n\n    cls = class_create(THIS_MODULE, DEVICE_NAME);\n    if (IS_ERR(cls)) {\n        printk(KERN_ERR \"Failed to create class\\n\");\n        cdev_del(&cdev);\n        unregister_chrdev_region(dev, 1);\n        return PTR_ERR(cls);\n    }\n\n    device_create(cls, NULL, dev, NULL, DEVICE_NAME);\n\n    hw_addr = ioremap(0x1000, 4096); //replace 0x1000 with your hardware address\n    if (!hw_addr) {\n        printk(KERN_ERR \"ioremap failed\\n\");\n        device_destroy(cls, dev);\n        class_destroy(cls);\n        cdev_del(&cdev);\n        unregister_chrdev_region(dev, 1);\n        return -1;\n    }\n\n\n    printk(KERN_INFO \"My hardware module loaded\\n\");\n    return 0;\n}\n\nstatic void __exit my_hardware_exit(void)\n{\n    iounmap(hw_addr);\n    device_destroy(cls, dev);\n    class_destroy(cls);\n    cdev_del(&cdev);\n    unregister_chrdev_region(dev, 1);\n    printk(KERN_INFO \"My hardware module unloaded\\n\");\n}\n\nmodule_init(my_hardware_init);\nmodule_exit(my_hardware_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"A simple hardware module\");\n```\n"
        },
        "gemini-2.5-flash": {
            "success": true,
            "code": "#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/slab.h>\n#include <linux/io.h>\n\n#define DRIVER_NAME \"my_hw_driver\"\n#define DEVICE_NAME \"my_hw_device\"\n\n/* Define \"registers\" for our dummy hardware */\nstruct my_hw_regs {\n    u32 control_reg;\n    u32 status_reg;\n    u32 data_reg;\n};\n\n/* Our device specific structure */\nstruct my_device {\n    struct platform_device *pdev; /* Pointer back to the platform device */\n    struct my_hw_regs *regs;      /* Pointer to our simulated hardware registers */\n};\n\n/* Global pointer to our simulated hardware registers.\n * In a real driver, this would be memory mapped via ioremap. */\nstatic struct my_hw_regs *g_my_hw_sim_regs;\n\n/* Helper functions to simulate register access */\nstatic inline u32 my_hw_read_reg(struct my_device *priv, u32 offset)\n{\n    u32 val;\n\n    /* In a real driver, this would be:\n     * return ioread32(priv->regs_base_addr + offset);\n     */\n    switch (offset) {\n        case 0: /* Control Register */\n            val = priv->regs->control_reg;\n            break;\n        case 4: /* Status Register */\n            val = priv->regs->status_reg;\n            break;\n        case 8: /* Data Register */\n            val = priv->regs->data_reg;\n            break;\n        default:\n            val = 0xFFFFFFFF; /* Indicate an error or unknown register */\n            dev_warn(&priv->pdev->dev, \"Attempted read from unknown offset 0x%x\\n\", offset);\n            break;\n    }\n    dev_info(&priv->pdev->dev, \"Read offset 0x%x, value 0x%x\\n\", offset, val);\n    return val;\n}\n\nstatic inline void my_hw_write_reg(struct my_device *priv, u32 offset, u32 val)\n{\n    /* In a real driver, this would be:\n     * iowrite32(val, priv->regs_base_addr + offset);\n     */\n    switch (offset) {\n        case 0: /* Control Register */\n            priv->regs->control_reg = val;\n            break;\n        case 8: /* Data Register */\n            priv->regs->data_reg = val;\n            break;\n        case 4: /* Status Register is read-only in this simulation */\n        default:\n            dev_warn(&priv->pdev->dev, \"Attempted write to invalid or read-only offset 0x%x with value 0x%x\\n\", offset, val);\n            return;\n    }\n    dev_info(&priv->pdev->dev, \"Write offset 0x%x, value 0x%x\\n\", offset, val);\n}\n\nstatic int my_hw_probe(struct platform_device *pdev)\n{\n    struct my_device *priv;\n    int ret = 0;\n\n    dev_info(&pdev->dev, \"Probe function called for %s\\n\", pdev->name);\n\n    priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n    if (!priv) {\n        dev_err(&pdev->dev, \"Failed to allocate private data\\n\");\n        return -ENOMEM;\n    }\n\n    platform_set_drvdata(pdev, priv);\n    priv->pdev = pdev;\n\n    /* Simulate \"ioremap\" or direct register access.\n     * In a real driver, priv->regs would be set up via a call to\n     * devm_ioremap_resource() or similar. Here, we just point to our\n     * globally allocated simulated registers. */\n    priv->regs = g_my_hw_sim_regs;\n\n    /* Initialize simulated hardware registers */\n    priv->regs->control_reg = 0x0;\n    priv->regs->status_reg = 0xDEADBEEF; /* Default status value */\n    priv->regs->data_reg = 0x0;\n\n    dev_info(&pdev->dev, \"Simulated hardware initialized.\\n\");\n\n    /* Demonstrate simulated hardware interaction */\n    my_hw_write_reg(priv, 0x0, 0x12345678); /* Write to control_reg */\n    my_hw_read_reg(priv, 0x0);              /* Read from control_reg */\n    my_hw_read_reg(priv, 0x4);              /* Read from status_reg */\n    my_hw_write_reg(priv, 0x8, 0xAABBCCDD); /* Write to data_reg */\n    my_hw_read_reg(priv, 0x8);              /* Read from data_reg */\n\n    dev_info(&pdev->dev, \"My hardware device probed successfully.\\n\");\n\n    return ret;\n}\n\nstatic int my_hw_remove(struct platform_device *pdev)\n{\n    dev_info(&pdev->dev, \"Remove function called for %s\\n\", pdev->name);\n\n    /* Any specific device cleanup goes here, e.g., disabling interrupts,\n     * powering down hardware, unmapping I/O memory if not using devm_\n     * functions for resource management. */\n\n    dev_info(&pdev->dev, \"My hardware device removed.\\n\");\n    return 0;\n}\n\nstatic void my_hw_release(struct device *dev)\n{\n    /* This function is called when the device object is no longer needed.\n     * For platform devices registered manually like this, it's often trivial,\n     * but could be used to free any device-specific data not managed by devm_\n     * functions. */\n    dev_info(dev, \"My hardware device released.\\n\");\n}\n\n/* Define the platform device that our driver will bind to */\nstatic struct platform_device my_hw_device = {\n    .name = DEVICE_NAME,\n    .id = -1, /* Use -1 for a single device instance */\n    .dev = {\n        .release = my_hw_release,\n    },\n};\n\n/* Define the platform device ID table for matching */\nstatic const struct platform_device_id my_hw_id_table[] = {\n    { DEVICE_NAME, 0 }, /* Match by name \"my_hw_device\" */\n    { } /* Sentinel value */\n};\nMODULE_DEVICE_TABLE(platform, my_hw_id_table);\n\n/* Define the platform driver */\nstatic struct platform_driver my_hw_driver = {\n    .probe = my_hw_probe,\n    .remove = my_hw_remove,\n    .driver = {\n        .name = DRIVER_NAME,\n        .owner = THIS_MODULE,\n        /* No of_match_table for this example, as we're not using Device Tree */\n    },\n    .id_table = my_hw_id_table,\n};\n\nstatic int __init my_hw_init(void)\n{\n    int ret;\n\n    printk(KERN_INFO DRIVER_NAME \": Initializing module\\n\");\n\n    /* Allocate memory for our simulated hardware registers.\n     * This simulates the physical registers that would be memory-mapped. */\n    g_my_hw_sim_regs = kzalloc(sizeof(*g_my_hw_sim_regs), GFP_KERNEL);\n    if (!g_my_hw_sim_regs) {\n        printk(KERN_ERR DRIVER_NAME \": Failed to allocate simulated registers\\n\");\n        return -ENOMEM;\n    }\n\n    /* Register the platform device. This will cause the driver's probe\n     * function to be called if it's already registered, or when it is. */\n    ret = platform_device_register(&my_hw_device);\n    if (ret) {\n        printk(KERN_ERR DRIVER_NAME \": Failed to register platform device: %d\\n\", ret);\n        kfree(g_my_hw_sim_regs); /* Clean up allocated simulation memory */\n        return ret;\n    }\n\n    /* Register the platform driver. If the device is already registered\n     * and matches, the probe function will be called. */\n    ret = platform_driver_register(&my_hw_driver);\n    if (ret) {\n        printk(KERN_ERR DRIVER_NAME \": Failed to register platform driver: %d\\n\", ret);\n        platform_device_unregister(&my_hw_device); /* Clean up device */\n        kfree(g_my_hw_sim_regs); /* Clean up allocated simulation memory */\n        return ret;\n    }\n\n    printk(KERN_INFO DRIVER_NAME \": Module initialized successfully\\n\");\n    return 0;\n}\n\nstatic void __exit my_hw_exit(void)\n{\n    printk(KERN_INFO DRIVER_NAME \": Exiting module\\n\");\n\n    /* Unregister the platform driver first */\n    platform_driver_unregister(&my_hw_driver);\n    /* Then unregister the platform device. This will trigger the driver's\n     * remove function if it was successfully probed. */\n    platform_device_unregister(&my_hw_device);\n\n    /* Free the memory used for simulated hardware registers */\n    kfree(g_my_hw_sim_regs);\n\n    printk(KERN_INFO DRIVER_NAME \": Module exited\\n\");\n}\n\nmodule_init(my_hw_init);\nmodule_exit(my_hw_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"A simple Linux kernel module demonstrating dummy hardware interaction via platform driver.\");"
        }
    }
}