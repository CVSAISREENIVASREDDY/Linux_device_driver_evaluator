{
    "Write a Linux kernel driver for a simple device.": {
        "gemini-1.5-flash": {
            "success": true,
            "code": "```c\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\n#define DEVICE_NAME \"simple_device\"\n#define DEVICE_MAJOR 240\n\nstatic dev_t dev;\nstatic struct cdev cdev;\nstatic struct class *cls;\n\nstatic int simple_device_open(struct inode *inode, struct file *filp)\n{\n    return 0;\n}\n\nstatic int simple_device_release(struct inode *inode, struct file *filp)\n{\n    return 0;\n}\n\nstatic ssize_t simple_device_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)\n{\n    return 0;\n}\n\nstatic ssize_t simple_device_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)\n{\n    return count;\n}\n\n\nstatic const struct file_operations simple_device_fops = {\n    .owner = THIS_MODULE,\n    .open = simple_device_open,\n    .release = simple_device_release,\n    .read = simple_device_read,\n    .write = simple_device_write,\n};\n\nstatic int __init simple_device_init(void)\n{\n    int ret;\n\n    ret = alloc_chrdev_region(&dev, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        printk(KERN_ERR \"Failed to register char device region\\n\");\n        return ret;\n    }\n\n    cdev_init(&cdev, &simple_device_fops);\n    ret = cdev_add(&cdev, dev, 1);\n    if (ret < 0) {\n        printk(KERN_ERR \"Failed to add char device\\n\");\n        unregister_chrdev_region(dev, 1);\n        return ret;\n    }\n\n    cls = class_create(THIS_MODULE, DEVICE_NAME);\n    if (IS_ERR(cls)) {\n        printk(KERN_ERR \"Failed to create class\\n\");\n        cdev_del(&cdev);\n        unregister_chrdev_region(dev, 1);\n        return PTR_ERR(cls);\n    }\n\n    device_create(cls, NULL, dev, NULL, DEVICE_NAME);\n\n    return 0;\n}\n\nstatic void __exit simple_device_exit(void)\n{\n    device_destroy(cls, dev);\n    class_destroy(cls);\n    cdev_del(&cdev);\n    unregister_chrdev_region(dev, 1);\n}\n\nmodule_init(simple_device_init);\nmodule_exit(simple_device_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Bard\");\nMODULE_DESCRIPTION(\"A simple Linux character device driver\");\n```\n"
        },
        "gemini-2.5-flash": {
            "success": true,
            "code": "#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n\n#define DRIVER_NAME \"simple_char_dev\"\n#define DEVICE_COUNT 1\n#define BUFFER_SIZE 256\n\nstatic dev_t simple_char_dev_num;\nstatic struct class *simple_char_dev_class;\nstatic struct cdev simple_char_dev_cdev;\n\nstatic char simple_char_dev_buffer[BUFFER_SIZE];\nstatic size_t simple_char_dev_buffer_len;\nstatic DEFINE_MUTEX(simple_char_dev_mutex);\n\nstatic int simple_char_dev_open(struct inode *inode, struct file *file)\n{\n\tif (!try_module_get(THIS_MODULE)) {\n\t\tpr_err(\"%s: Failed to get module usage count\\n\", DRIVER_NAME);\n\t\treturn -ENODEV;\n\t}\n\tpr_info(\"%s: Device opened\\n\", DRIVER_NAME);\n\treturn 0;\n}\n\nstatic int simple_char_dev_release(struct inode *inode, struct file *file)\n{\n\tmodule_put(THIS_MODULE);\n\tpr_info(\"%s: Device closed\\n\", DRIVER_NAME);\n\treturn 0;\n}\n\nstatic ssize_t simple_char_dev_read(struct file *filp, char __user *buf, size_t count, loff_t *ppos)\n{\n\tssize_t retval = 0;\n\tsize_t bytes_to_read;\n\n\tif (mutex_lock_interruptible(&simple_char_dev_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (*ppos >= simple_char_dev_buffer_len) {\n\t\tgoto out; /* No data left to read from current position */\n\t}\n\n\tbytes_to_read = min((size_t)count, simple_char_dev_buffer_len - (size_t)*ppos);\n\n\tif (copy_to_user(buf, simple_char_dev_buffer + *ppos, bytes_to_read)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t*ppos += bytes_to_read;\n\tretval = bytes_to_read;\n\nout:\n\tmutex_unlock(&simple_char_dev_mutex);\n\treturn retval;\n}\n\nstatic ssize_t simple_char_dev_write(struct file *filp, const char __user *buf, size_t count, loff_t *ppos)\n{\n\tssize_t retval = 0;\n\tsize_t bytes_to_write;\n\n\tif (mutex_lock_interruptible(&simple_char_dev_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tif (*ppos > BUFFER_SIZE) {\n\t\tretval = -EFBIG; /* Cannot write beyond buffer capacity */\n\t\tgoto out;\n\t}\n\n\tbytes_to_write = min((size_t)count, (size_t)(BUFFER_SIZE - *ppos));\n\n\tif (copy_from_user(simple_char_dev_buffer + *ppos, buf, bytes_to_write)) {\n\t\tretval = -EFAULT;\n\t\tgoto out;\n\t}\n\n\t*ppos += bytes_to_write;\n\tif (*ppos > simple_char_dev_buffer_len)\n\t\tsimple_char_dev_buffer_len = *ppos;\n\n\tretval = bytes_to_write;\n\nout:\n\tmutex_unlock(&simple_char_dev_mutex);\n\treturn retval;\n}\n\nstatic const struct file_operations simple_char_dev_fops = {\n\t.owner = THIS_MODULE,\n\t.open = simple_char_dev_open,\n\t.release = simple_char_dev_release,\n\t.read = simple_char_dev_read,\n\t.write = simple_char_dev_write,\n};\n\nstatic int __init simple_char_dev_init(void)\n{\n\tint ret;\n\tstruct device *dev_ret;\n\n\tret = alloc_chrdev_region(&simple_char_dev_num, 0, DEVICE_COUNT, DRIVER_NAME);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: Failed to allocate major/minor numbers: %d\\n\", DRIVER_NAME, ret);\n\t\treturn ret;\n\t}\n\n\tcdev_init(&simple_char_dev_cdev, &simple_char_dev_fops);\n\tsimple_char_dev_cdev.owner = THIS_MODULE;\n\n\tret = cdev_add(&simple_char_dev_cdev, simple_char_dev_num, DEVICE_COUNT);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: Failed to add cdev: %d\\n\", DRIVER_NAME, ret);\n\t\tgoto unregister_chrdev;\n\t}\n\n\tsimple_char_dev_class = class_create(THIS_MODULE, DRIVER_NAME);\n\tif (IS_ERR(simple_char_dev_class)) {\n\t\tpr_err(\"%s: Failed to create device class\\n\", DRIVER_NAME);\n\t\tret = PTR_ERR(simple_char_dev_class);\n\t\tgoto cdev_del;\n\t}\n\n\tdev_ret = device_create(simple_char_dev_class, NULL, simple_char_dev_num, NULL, DRIVER_NAME \"%d\", MINOR(simple_char_dev_num));\n\tif (IS_ERR(dev_ret)) {\n\t\tpr_err(\"%s: Failed to create device\\n\", DRIVER_NAME);\n\t\tret = PTR_ERR(dev_ret);\n\t\tgoto class_destroy;\n\t}\n\n\tsimple_char_dev_buffer_len = 0; /* Initialize buffer as empty */\n\tpr_info(\"%s: Device initialized with major %d, minor %d\\n\", DRIVER_NAME, MAJOR(simple_char_dev_num), MINOR(simple_char_dev_num));\n\treturn 0;\n\nclass_destroy:\n\tclass_destroy(simple_char_dev_class);\ncdev_del:\n\tcdev_del(&simple_char_dev_cdev);\nunregister_chrdev:\n\tunregister_chrdev_region(simple_char_dev_num, DEVICE_COUNT);\n\treturn ret;\n}\n\nstatic void __exit simple_char_dev_exit(void)\n{\n\tdevice_destroy(simple_char_dev_class, simple_char_dev_num);\n\tclass_destroy(simple_char_dev_class);\n\tcdev_del(&simple_char_dev_cdev);\n\tunregister_chrdev_region(simple_char_dev_num, DEVICE_COUNT);\n\tpr_info(\"%s: Device uninitialized\\n\", DRIVER_NAME);\n}\n\nmodule_init(simple_char_dev_init);\nmodule_exit(simple_char_dev_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"A simple character device driver example.\");"
        }
    },
    "2Implement a character device driver with basic read/write operations.": {
        "gemini-1.5-flash": {
            "success": true,
            "code": "```c\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\n#define DEVICE_NAME \"chardev\"\n#define MAX_BUFFER_SIZE 1024\n\nstatic char *buffer;\nstatic dev_t dev;\nstatic struct cdev cdev;\nstatic struct class *cls;\n\nstatic int chardev_open(struct inode *inode, struct file *file) {\n    return 0;\n}\n\nstatic int chardev_release(struct inode *inode, struct file *file) {\n    return 0;\n}\n\nstatic ssize_t chardev_read(struct file *file, char __user *user_buffer, size_t count, loff_t *offset) {\n    size_t bytes_to_read = min(count, strlen(buffer) - *offset);\n    if (bytes_to_read == 0) return 0;\n    if (copy_to_user(user_buffer, buffer + *offset, bytes_to_read)) return -EFAULT;\n    *offset += bytes_to_read;\n    return bytes_to_read;\n}\n\nstatic ssize_t chardev_write(struct file *file, const char __user *user_buffer, size_t count, loff_t *offset) {\n    size_t bytes_to_write = min(count, MAX_BUFFER_SIZE - *offset);\n    if (bytes_to_write == 0) return 0;\n    if (copy_from_user(buffer + *offset, user_buffer, bytes_to_write)) return -EFAULT;\n    *offset += bytes_to_write;\n    return bytes_to_write;\n}\n\n\nstatic const struct file_operations chardev_fops = {\n    .owner = THIS_MODULE,\n    .open = chardev_open,\n    .release = chardev_release,\n    .read = chardev_read,\n    .write = chardev_write,\n};\n\nstatic int __init chardev_init(void) {\n    int ret;\n    ret = alloc_chrdev_region(&dev, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        printk(KERN_ERR \"Failed to register char device\\n\");\n        return ret;\n    }\n    buffer = kmalloc(MAX_BUFFER_SIZE, GFP_KERNEL);\n    if (!buffer) {\n        unregister_chrdev_region(dev, 1);\n        printk(KERN_ERR \"Failed to allocate buffer\\n\");\n        return -ENOMEM;\n    }\n    cdev_init(&cdev, &chardev_fops);\n    ret = cdev_add(&cdev, dev, 1);\n    if (ret < 0) {\n        kfree(buffer);\n        unregister_chrdev_region(dev, 1);\n        printk(KERN_ERR \"Failed to add char device\\n\");\n        return ret;\n    }\n    cls = class_create(THIS_MODULE, DEVICE_NAME);\n    if (IS_ERR(cls)) {\n        cdev_del(&cdev);\n        kfree(buffer);\n        unregister_chrdev_region(dev, 1);\n        printk(KERN_ERR \"Failed to create class\\n\");\n        return PTR_ERR(cls);\n    }\n    device_create(cls, NULL, dev, NULL, DEVICE_NAME);\n    printk(KERN_INFO \"Char device registered\\n\");\n    return 0;\n}\n\nstatic void __exit chardev_exit(void) {\n    device_destroy(cls, dev);\n    class_destroy(cls);\n    cdev_del(&cdev);\n    kfree(buffer);\n    unregister_chrdev_region(dev, 1);\n    printk(KERN_INFO \"Char device unregistered\\n\");\n}\n\nmodule_init(chardev_init);\nmodule_exit(chardev_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Bard\");\nMODULE_DESCRIPTION(\"A simple character device driver\");\n```\n"
        },
        "gemini-2.5-flash": {
            "success": true,
            "code": "```c\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/mutex.h>\n\n#define DEVICE_NAME \"mychardev\"\n#define CLASS_NAME  \"mychardev_class\"\n#define BUFFER_SIZE (1024)\n\nstatic dev_t my_dev_nr;\nstatic struct cdev my_cdev;\nstatic struct class *my_class;\nstatic char *device_buffer;\nstatic size_t buffer_data_len;\nstatic DEFINE_MUTEX(my_mutex); /* Protects access to device_buffer and buffer_data_len */\n\nstatic int my_open(struct inode *inode, struct file *file)\n{\n\tif (mutex_lock_interruptible(&my_mutex))\n\t\treturn -ERESTARTSYS;\n\n\tpr_info(\"%s: Device opened\\n\", DEVICE_NAME);\n\tmutex_unlock(&my_mutex);\n\treturn 0;\n}\n\nstatic int my_release(struct inode *inode, struct file *file)\n{\n\tpr_info(\"%s: Device closed\\n\", DEVICE_NAME);\n\treturn 0;\n}\n\nstatic ssize_t my_read(struct file *file, char __user *buf, size_t count, loff_t *offset)\n{\n\tsize_t bytes_to_read;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&my_mutex))\n\t\treturn -ERESTARTSYS;\n\n\t/* If read offset is beyond the buffer's data length, return EOF */\n\tif (*offset >= buffer_data_len) {\n\t\tret = 0;\n\t\tgoto unlock_and_return;\n\t}\n\n\tbytes_to_read = min((size_t)count, buffer_data_len - (size_t)*offset);\n\n\tif (copy_to_user(buf, device_buffer + *offset, bytes_to_read)) {\n\t\tret = -EFAULT;\n\t\tgoto unlock_and_return;\n\t}\n\n\t*offset += bytes_to_read;\n\tret = bytes_to_read;\n\nunlock_and_return:\n\tmutex_unlock(&my_mutex);\n\tpr_info(\"%s: Read %zd bytes, offset %lld\\n\", DEVICE_NAME, (ssize_t)bytes_to_read, *offset);\n\treturn ret;\n}\n\nstatic ssize_t my_write(struct file *file, const char __user *buf, size_t count, loff_t *offset)\n{\n\tsize_t bytes_to_write;\n\tint ret;\n\n\tif (mutex_lock_interruptible(&my_mutex))\n\t\treturn -ERESTARTSYS;\n\n\t/* Ensure we don't write beyond the buffer size */\n\tbytes_to_write = min((size_t)count, (size_t)BUFFER_SIZE - (size_t)*offset);\n\n\t/* If offset is beyond the buffer's total size, return error */\n\tif (*offset >= BUFFER_SIZE) {\n\t\tpr_err(\"%s: Write offset %lld out of bounds\\n\", DEVICE_NAME, *offset);\n\t\tret = -ENOSPC; /* No space left on device */\n\t\tgoto unlock_and_return;\n\t}\n\n\tif (copy_from_user(device_buffer + *offset, buf, bytes_to_write)) {\n\t\tret = -EFAULT;\n\t\tgoto unlock_and_return;\n\t}\n\n\t*offset += bytes_to_write;\n\t/* Update the actual data length in the buffer */\n\tif (*offset > buffer_data_len)\n\t\tbuffer_data_len = *offset;\n\n\tret = bytes_to_write;\n\nunlock_and_return:\n\tmutex_unlock(&my_mutex);\n\tpr_info(\"%s: Written %zd bytes, offset %lld, data_len %zu\\n\",\n\t\tDEVICE_NAME, (ssize_t)bytes_to_write, *offset, buffer_data_len);\n\treturn ret;\n}\n\nstatic const struct file_operations my_fops = {\n\t.owner   = THIS_MODULE,\n\t.open    = my_open,\n\t.release = my_release,\n\t.read    = my_read,\n\t.write   = my_write,\n\t.llseek  = no_llseek, /* For simplicity, disable seeking for now */\n};\n\nstatic int __init my_init(void)\n{\n\tint ret;\n\n\tpr_info(\"%s: Initializing the character device module\\n\", DEVICE_NAME);\n\n\t/* 1. Dynamically allocate a major and minor number */\n\tret = alloc_chrdev_region(&my_dev_nr, 0, 1, DEVICE_NAME);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: Failed to allocate char device region (%d)\\n\", DEVICE_NAME, ret);\n\t\tgoto out_exit;\n\t}\n\tpr_info(\"%s: Allocated device number: %d:%d\\n\", DEVICE_NAME, MAJOR(my_dev_nr), MINOR(my_dev_nr));\n\n\t/* 2. Create a device class (for udev automatic device node creation) */\n\tmy_class = class_create(THIS_MODULE, CLASS_NAME);\n\tif (IS_ERR(my_class)) {\n\t\tret = PTR_ERR(my_class);\n\t\tpr_err(\"%s: Failed to create device class (%d)\\n\", DEVICE_NAME, ret);\n\t\tgoto out_unregister_chrdev;\n\t}\n\n\t/* 3. Create a device */\n\tif (IS_ERR(device_create(my_class, NULL, my_dev_nr, NULL, DEVICE_NAME))) {\n\t\tret = PTR_ERR(device_create(my_class, NULL, my_dev_nr, NULL, DEVICE_NAME));\n\t\tpr_err(\"%s: Failed to create device (%d)\\n\", DEVICE_NAME, ret);\n\t\tgoto out_destroy_class;\n\t}\n\n\t/* 4. Initialize the cdev structure and add it to the kernel */\n\tcdev_init(&my_cdev, &my_fops);\n\tmy_cdev.owner = THIS_MODULE;\n\tret = cdev_add(&my_cdev, my_dev_nr, 1);\n\tif (ret < 0) {\n\t\tpr_err(\"%s: Failed to add cdev (%d)\\n\", DEVICE_NAME, ret);\n\t\tgoto out_destroy_device;\n\t}\n\n\t/* 5. Allocate the device buffer */\n\tdevice_buffer = kmalloc(BUFFER_SIZE, GFP_KERNEL);\n\tif (!device_buffer) {\n\t\tret = -ENOMEM;\n\t\tpr_err(\"%s: Failed to allocate device buffer\\n\", DEVICE_NAME);\n\t\tgoto out_del_cdev;\n\t}\n\tbuffer_data_len = 0; /* Initially, buffer is empty */\n\tmemset(device_buffer, 0, BUFFER_SIZE); /* Clear buffer */\n\n\tpr_info(\"%s: Character device module loaded\\n\", DEVICE_NAME);\n\treturn 0;\n\nout_del_cdev:\n\tcdev_del(&my_cdev);\nout_destroy_device:\n\tdevice_destroy(my_class, my_dev_nr);\nout_destroy_class:\n\tclass_destroy(my_class);\nout_unregister_chrdev:\n\tunregister_chrdev_region(my_dev_nr, 1);\nout_exit:\n\treturn ret;\n}\n\nstatic void __exit my_exit(void)\n{\n\tpr_info(\"%s: Exiting character device module\\n\", DEVICE_NAME);\n\n\t/* Free the device buffer */\n\tkfree(device_buffer);\n\n\t/* Delete the cdev */\n\tcdev_del(&my_cdev);\n\n\t/* Destroy the device */\n\tdevice_destroy(my_class, my_dev_nr);\n\n\t/* Destroy the class */\n\tclass_destroy(my_class);\n\n\t/* Unregister the character device region */\n\tunregister_chrdev_region(my_dev_nr, 1);\n\n\tpr_info(\"%s: Character device module unloaded\\n\", DEVICE_NAME);\n}\n\nmodule_init(my_init);\nmodule_exit(my_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"A simple character device driver with read/write\");\nMODULE_VERSION(\"0.1\");\n```"
        }
    },
    "Create a kernel module that interacts with hardware.": {
        "gemini-1.5-flash": {
            "success": true,
            "code": "```c\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <linux/io.h>\n\n#define DEVICE_NAME \"my_hardware\"\n#define MY_HARDWARE_BASE 0x1000 // Replace with actual hardware base address\n\nstatic dev_t my_dev;\nstatic struct cdev my_cdev;\nstatic struct class *my_class;\nstatic void __iomem *my_hardware_base;\n\nstatic int my_hardware_open(struct inode *inode, struct file *file) {\n    return 0;\n}\n\nstatic int my_hardware_release(struct inode *inode, struct file *file) {\n    return 0;\n}\n\nstatic ssize_t my_hardware_read(struct file *file, char __user *buf, size_t count, loff_t *ppos) {\n    unsigned long value;\n    if(count > sizeof(value)){\n        return -EINVAL;\n    }\n    value = ioread32(my_hardware_base); // Replace with appropriate ioread function\n    if(copy_to_user(buf, &value, sizeof(value))){\n        return -EFAULT;\n    }\n    return sizeof(value);\n\n}\n\nstatic ssize_t my_hardware_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos) {\n    unsigned long value;\n    if(count > sizeof(value)){\n        return -EINVAL;\n    }\n    if(copy_from_user(&value, buf, sizeof(value))){\n        return -EFAULT;\n    }\n    iowrite32(value, my_hardware_base); // Replace with appropriate iowrite function\n    return count;\n}\n\n\nstatic const struct file_operations my_hardware_fops = {\n    .owner = THIS_MODULE,\n    .open = my_hardware_open,\n    .release = my_hardware_release,\n    .read = my_hardware_read,\n    .write = my_hardware_write,\n};\n\nstatic int __init my_hardware_init(void) {\n    int ret;\n    ret = alloc_chrdev_region(&my_dev, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        printk(KERN_ERR \"Failed to allocate character device region\\n\");\n        return ret;\n    }\n    cdev_init(&my_cdev, &my_hardware_fops);\n    ret = cdev_add(&my_cdev, my_dev, 1);\n    if (ret < 0) {\n        printk(KERN_ERR \"Failed to add character device\\n\");\n        unregister_chrdev_region(my_dev, 1);\n        return ret;\n    }\n\n    my_class = class_create(THIS_MODULE, DEVICE_NAME);\n    if (IS_ERR(my_class)) {\n        printk(KERN_ERR \"Failed to create class\\n\");\n        cdev_del(&my_cdev);\n        unregister_chrdev_region(my_dev, 1);\n        return PTR_ERR(my_class);\n    }\n    device_create(my_class, NULL, my_dev, NULL, DEVICE_NAME);\n    my_hardware_base = ioremap(MY_HARDWARE_BASE, 4); //Replace 4 with appropriate size.\n    if (!my_hardware_base) {\n        printk(KERN_ERR \"ioremap failed\\n\");\n        device_destroy(my_class, my_dev);\n        class_destroy(my_class);\n        cdev_del(&my_cdev);\n        unregister_chrdev_region(my_dev, 1);\n        return -ENOMEM;\n\n    }\n    printk(KERN_INFO \"My hardware module loaded\\n\");\n    return 0;\n}\n\nstatic void __exit my_hardware_exit(void) {\n    iounmap(my_hardware_base);\n    device_destroy(my_class, my_dev);\n    class_destroy(my_class);\n    cdev_del(&my_cdev);\n    unregister_chrdev_region(my_dev, 1);\n    printk(KERN_INFO \"My hardware module unloaded\\n\");\n}\n\nmodule_init(my_hardware_init);\nmodule_exit(my_hardware_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Bard\");\nMODULE_DESCRIPTION(\"A simple hardware interaction module\");\n```\n"
        },
        "gemini-2.5-flash": {
            "success": true,
            "code": "```c\n#include <linux/module.h>\n#include <linux/platform_device.h>\n#include <linux/fs.h>           // For file_operations, register_chrdev_region, etc.\n#include <linux/cdev.h>         // For cdev\n#include <linux/io.h>           // For ioremap, iounmap, readl, writel\n#include <linux/uaccess.h>      // For copy_to_user, copy_from_user\n#include <linux/slab.h>         // For kmalloc/kfree (used via devm_kzalloc)\n#include <linux/err.h>          // For IS_ERR, PTR_ERR\n#include <linux/device.h>       // For class_create, device_create\n\n// --- Device specific defines ---\n#define DRIVER_NAME \"my_hw_driver\"\n#define DEVICE_COUNT 1\n// Dummy base address for our simulated hardware, choose a high unused address for safety\n#define MY_HW_REG_BASE_ADDR 0xDEAD0000UL\n#define MY_HW_REG_SIZE      0x1000UL     // 4KB region for simulated registers\n\n// --- Private data structure for the device ---\nstruct my_hw_dev {\n    struct cdev cdev;\n    dev_t dev_num;\n    void __iomem *reg_base; // Mapped I/O memory base address\n    u32 hw_value;           // A simple value to simulate a hardware register content\n    struct device *dev;     // Pointer to the struct device created by device_create\n};\n\nstatic struct class *my_hw_class; // Global class for udev integration\nstatic struct my_hw_dev *my_hw_priv_data; // Pointer to our device private data (only one device in this example)\n\n// --- File Operations ---\n\nstatic int my_hw_open(struct inode *inode, struct file *file)\n{\n    struct my_hw_dev *priv = container_of(inode->i_cdev, struct my_hw_dev, cdev);\n    file->private_data = priv;\n    dev_info(priv->dev, \"Device opened\\n\");\n    return 0;\n}\n\nstatic int my_hw_release(struct inode *inode, struct file *file)\n{\n    struct my_hw_dev *priv = file->private_data;\n    dev_info(priv->dev, \"Device closed\\n\");\n    return 0;\n}\n\nstatic ssize_t my_hw_read(struct file *file, char __user *buf, size_t count, loff_t *pos)\n{\n    struct my_hw_dev *priv = file->private_data;\n    u32 reg_val;\n\n    // For simplicity, only allow reading a single 32-bit value from offset 0\n    if (*pos != 0)\n        return 0;\n\n    if (count < sizeof(reg_val)) {\n        dev_err(priv->dev, \"Read size too small, expected %zu bytes\\n\", sizeof(reg_val));\n        return -EINVAL;\n    }\n\n    // Simulate reading from a hardware register.\n    // In a real driver, this would typically involve: reg_val = readl(priv->reg_base);\n    // Here, we just return our internal simulated value.\n    reg_val = priv->hw_value;\n\n    dev_info(priv->dev, \"Reading simulated HW value: 0x%x\\n\", reg_val);\n\n    if (copy_to_user(buf, &reg_val, sizeof(reg_val))) {\n        dev_err(priv->dev, \"Failed to copy data to user\\n\");\n        return -EFAULT;\n    }\n\n    *pos += sizeof(reg_val);\n    return sizeof(reg_val);\n}\n\nstatic ssize_t my_hw_write(struct file *file, const char __user *buf, size_t count, loff_t *pos)\n{\n    struct my_hw_dev *priv = file->private_data;\n    u32 reg_val;\n\n    // For simplicity, only allow writing a single 32-bit value to offset 0\n    if (*pos != 0)\n        return -EINVAL;\n\n    if (count < sizeof(reg_val)) {\n        dev_err(priv->dev, \"Write size too small, expected %zu bytes\\n\", sizeof(reg_val));\n        return -EINVAL;\n    }\n\n    if (copy_from_user(&reg_val, buf, sizeof(reg_val))) {\n        dev_err(priv->dev, \"Failed to copy data from user\\n\");\n        return -EFAULT;\n    }\n\n    // Simulate writing to a hardware register.\n    // In a real driver, this would typically involve: writel(reg_val, priv->reg_base);\n    priv->hw_value = reg_val;\n    dev_info(priv->dev, \"Writing simulated HW value: 0x%x\\n\", reg_val);\n\n    *pos += sizeof(reg_val);\n    return sizeof(reg_val);\n}\n\nstatic const struct file_operations my_hw_fops = {\n    .owner = THIS_MODULE,\n    .open = my_hw_open,\n    .release = my_hw_release,\n    .read = my_hw_read,\n    .write = my_hw_write,\n};\n\n// --- Platform Driver Functions ---\n\nstatic int my_hw_probe(struct platform_device *pdev)\n{\n    struct resource *res;\n    int ret;\n\n    my_hw_priv_data = devm_kzalloc(&pdev->dev, sizeof(*my_hw_priv_data), GFP_KERNEL);\n    if (!my_hw_priv_data)\n        return -ENOMEM;\n\n    platform_set_drvdata(pdev, my_hw_priv_data);\n\n    // 1. Get memory resource defined in the platform device\n    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n    if (!res) {\n        dev_err(&pdev->dev, \"No IORESOURCE_MEM found\\n\");\n        return -EINVAL;\n    }\n\n    // 2. Request and map I/O memory.\n    // devm_ioremap_resource handles request_mem_region and ioremap,\n    // and ensures automatic cleanup on probe exit or module unload.\n    my_hw_priv_data->reg_base = devm_ioremap_resource(&pdev->dev, res);\n    if (IS_ERR(my_hw_priv_data->reg_base)) {\n        dev_err(&pdev->dev, \"Failed to remap I/O memory: %ld\\n\", PTR_ERR(my_hw_priv_data->reg_base));\n        return PTR_ERR(my_hw_priv_data->reg_base);\n    }\n    dev_info(&pdev->dev, \"Mapped HW registers at physical 0x%lx to virtual 0x%p (len %lu)\\n\",\n             (unsigned long)res->start, my_hw_priv_data->reg_base, resource_size(res));\n\n    // 3. Allocate character device region\n    ret = alloc_chrdev_region(&my_hw_priv_data->dev_num, 0, DEVICE_COUNT, DRIVER_NAME);\n    if (ret < 0) {\n        dev_err(&pdev->dev, \"Failed to allocate character device region: %d\\n\", ret);\n        return ret;\n    }\n\n    // 4. Initialize and add the character device\n    cdev_init(&my_hw_priv_data->cdev, &my_hw_fops);\n    my_hw_priv_data->cdev.owner = THIS_MODULE;\n\n    ret = cdev_add(&my_hw_priv_data->cdev, my_hw_priv_data->dev_num, DEVICE_COUNT);\n    if (ret < 0) {\n        dev_err(&pdev->dev, \"Failed to add character device: %d\\n\", ret);\n        goto err_cdev_add;\n    }\n\n    // 5. Create device class if it doesn't exist (only once per module)\n    if (!my_hw_class) {\n        my_hw_class = class_create(THIS_MODULE, DRIVER_NAME);\n        if (IS_ERR(my_hw_class)) {\n            dev_err(&pdev->dev, \"Failed to create device class: %ld\\n\", PTR_ERR(my_hw_class));\n            ret = PTR_ERR(my_hw_class);\n            goto err_class_create;\n        }\n    }\n\n    // 6. Create the device node in /dev/\n    my_hw_priv_data->dev = device_create(my_hw_class, &pdev->dev, my_hw_priv_data->dev_num,\n                                        NULL, DRIVER_NAME \"%d\", 0); // Creates /dev/my_hw_driver0\n    if (IS_ERR(my_hw_priv_data->dev)) {\n        dev_err(&pdev->dev, \"Failed to create device node: %ld\\n\", PTR_ERR(my_hw_priv_data->dev));\n        ret = PTR_ERR(my_hw_priv_data->dev);\n        goto err_device_create;\n    }\n\n    dev_info(my_hw_priv_data->dev, DRIVER_NAME \" device registered. Major: %d, Minor: %d\\n\",\n             MAJOR(my_hw_priv_data->dev_num), MINOR(my_hw_priv_data->dev_num));\n\n    // Initialize simulated hardware value\n    my_hw_priv_data->hw_value = 0x12345678;\n\n    return 0;\n\nerr_device_create:\n    // If device_create failed, no need to destroy it.\n    // The class is global and will be destroyed in module_exit if no other devices use it.\nerr_class_create:\n    cdev_del(&my_hw_priv_data->cdev);\nerr_cdev_add:\n    unregister_chrdev_region(my_hw_priv_data->dev_num, DEVICE_COUNT);\n    // devm_kzalloc and devm_ioremap_resource are automatically handled by the kernel\n    // when the probe function returns an error code.\n    return ret;\n}\n\nstatic int my_hw_remove(struct platform_device *pdev)\n{\n    struct my_hw_dev *priv = platform_get_drvdata(pdev);\n\n    dev_info(&pdev->dev, DRIVER_NAME \" device removed\\n\");\n\n    // Destroy the device node\n    device_destroy(my_hw_class, priv->dev_num);\n    // Delete the character device\n    cdev_del(&priv->cdev);\n    // Unregister the character device region\n    unregister_chrdev_region(priv->dev_num, DEVICE_COUNT);\n    // devm_managed resources (memory, ioremap) are automatically freed when the device is unbound.\n\n    return 0;\n}\n\n// --- Platform Device & Driver definitions ---\n\n// Used for device matching by ID table\nstatic const struct platform_device_id my_hw_id_table[] = {\n    { DRIVER_NAME, 0 },\n    { /* sentinel */ },\n};\nMODULE_DEVICE_TABLE(platform, my_hw_id_table);\n\nstatic struct platform_driver my_hw_driver = {\n    .probe = my_hw_probe,\n    .remove = my_hw_remove,\n    .driver = {\n        .name = DRIVER_NAME,\n        .of_match_table = NULL, // Not using device tree for this simple example\n        .id_table = my_hw_id_table,\n    },\n};\n\n// --- Dummy Platform Device to register ---\n// This struct simulates a piece of hardware and is registered by the module\n// to trigger the platform driver's probe function.\nstatic struct resource my_hw_device_resources[] = {\n    {\n        .start = MY_HW_REG_BASE_ADDR,\n        .end = MY_HW_REG_BASE_ADDR + MY_HW_REG_SIZE - 1,\n        .name = \"my_hw_regs\",\n        .flags = IORESOURCE_MEM,\n    },\n};\n\nstatic struct platform_device my_hw_platform_device = {\n    .name = DRIVER_NAME,\n    .id = -1, // -1 means no specific ID, uses name matching\n    .num_resources = ARRAY_SIZE(my_hw_device_resources),\n    .resource = my_hw_device_resources,\n};\n\n// --- Module Init/Exit ---\n\nstatic int __init my_hw_module_init(void)\n{\n    int ret;\n\n    pr_info(DRIVER_NAME \": Initializing module\\n\");\n\n    // 1. Register the dummy platform device.\n    // This will typically trigger the probe function of a matching platform driver.\n    ret = platform_device_register(&my_hw_platform_device);\n    if (ret < 0) {\n        pr_err(DRIVER_NAME \": Failed to register platform device: %d\\n\", ret);\n        return ret;\n    }\n\n    // 2. Register the platform driver.\n    ret = platform_driver_register(&my_hw_driver);\n    if (ret < 0) {\n        pr_err(DRIVER_NAME \": Failed to register platform driver: %d\\n\", ret);\n        // If driver registration fails, unregister the device that was just registered.\n        platform_device_unregister(&my_hw_platform_device);\n        return ret;\n    }\n\n    return 0;\n}\n\nstatic void __exit my_hw_module_exit(void)\n{\n    pr_info(DRIVER_NAME \": Exiting module\\n\");\n\n    // 1. Unregister the platform driver.\n    // This will implicitly call the remove function for any devices bound to this driver.\n    platform_driver_unregister(&my_hw_driver);\n\n    // 2. Unregister the dummy platform device.\n    platform_device_unregister(&my_hw_platform_device);\n\n    // 3. Destroy the device class if it was created.\n    if (my_hw_class) {\n        class_destroy(my_hw_class);\n        my_hw_class = NULL;\n    }\n}\n\nmodule_init(my_hw_module_init);\nmodule_exit(my_hw_module_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name\");\nMODULE_DESCRIPTION(\"A simple kernel module interacting with simulated hardware via a platform device and character device.\");\nMODULE_VERSION(\"0.1\");\n```"
        }
    }
}