{
    "Write a Linux kernel driver for a simple device.": {
        "gemini-1.5-flash": {
            "success": true,
            "code": "This driver simulates a simple device that increments a counter on each read operation.  It uses a single `char` device.\n\n```c\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/slab.h>\n\n\n#define DEVICE_NAME \"simple_counter\"\n#define MAX_COUNT 1000\n\n\nstatic int major_number;\nstatic struct cdev cdev;\nstatic dev_t dev;\nstatic struct class *cls;\nstatic unsigned int counter = 0;\n\n\nstatic int simple_counter_open(struct inode *inode, struct file *filp) {\n    printk(KERN_INFO \"simple_counter: Device opened\\n\");\n    return 0;\n}\n\nstatic int simple_counter_release(struct inode *inode, struct file *filp) {\n    printk(KERN_INFO \"simple_counter: Device released\\n\");\n    return 0;\n}\n\nstatic ssize_t simple_counter_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos) {\n    unsigned int val;\n    int ret;\n\n    if (*f_pos >= MAX_COUNT) {\n        return 0; //End of counter\n    }\n\n    if (counter >= MAX_COUNT) {\n        printk(KERN_WARNING \"simple_counter: Counter reached maximum value.\\n\");\n        return 0;\n    }\n    \n    val = ++counter;\n\n    ret = copy_to_user(buf, &val, sizeof(val));\n    if (ret != 0) {\n        printk(KERN_ERR \"simple_counter: Error copying to user space: %d\\n\", ret);\n        return -EFAULT;\n    }\n\n    *f_pos += sizeof(val);\n    return sizeof(val);\n}\n\nstatic const struct file_operations simple_counter_fops = {\n    .owner = THIS_MODULE,\n    .open = simple_counter_open,\n    .release = simple_counter_release,\n    .read = simple_counter_read,\n};\n\n\nstatic int __init simple_counter_init(void) {\n    int ret;\n\n    ret = alloc_chrdev_region(&dev, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        printk(KERN_ERR \"simple_counter: Failed to register char device: %d\\n\", ret);\n        return ret;\n    }\n    major_number = MAJOR(dev);\n    printk(KERN_INFO \"simple_counter: Major number: %d\\n\", major_number);\n\n    cdev_init(&cdev, &simple_counter_fops);\n\n    ret = cdev_add(&cdev, dev, 1);\n    if (ret < 0) {\n        printk(KERN_ERR \"simple_counter: Failed to add cdev: %d\\n\", ret);\n        goto unreg_chrdev;\n    }\n\n    cls = class_create(THIS_MODULE, DEVICE_NAME);\n    if (IS_ERR(cls)) {\n        printk(KERN_ERR \"simple_counter: Failed to create class: %ld\\n\", PTR_ERR(cls));\n        goto del_cdev;\n    }\n\n    device_create(cls, NULL, dev, NULL, DEVICE_NAME);\n\n\n    return 0;\n\ndel_cdev:\n    cdev_del(&cdev);\nunreg_chrdev:\n    unregister_chrdev_region(dev, 1);\n    return ret;\n}\n\n\nstatic void __exit simple_counter_exit(void) {\n    device_destroy(cls, dev);\n    class_destroy(cls);\n    cdev_del(&cdev);\n    unregister_chrdev_region(dev, 1);\n    printk(KERN_INFO \"simple_counter: Module unloaded\\n\");\n}\n\n\nmodule_init(simple_counter_init);\nmodule_exit(simple_counter_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Bard\");\nMODULE_DESCRIPTION(\"A simple counter device driver\");\n```\n\nTo compile and load this driver, save it as `simple_counter.c`, then compile it using a kernel build system (like `make` within a kernel tree) after adding it to your kernel's `drivers` directory.  Remember to adjust the Makefile accordingly and  make sure your kernel build system is properly set up.   After successful compilation, load the module using `sudo insmod simple_counter.ko`.  You can then access the device using standard Linux device access methods. Remember to unload the driver using `sudo rmmod simple_counter.ko` after you're done.  This example provides error handling and follows kernel coding style guidelines more strictly.  Always remember to test your driver thoroughly in a safe environment.\n"
        },
        "gemini-2.5-flash": {
            "success": true,
            "code": "This example creates a simple character device driver named \"mydev\". It provides a fixed-size buffer that user applications can read from and write to.\n\n**Features:**\n*   **Character Device:** Registers a character device `/dev/mydev`.\n*   **Dynamic Major Number Allocation:** Uses `alloc_chrdev_region` for flexibility.\n*   **Device Class & Node Creation:** Uses `class_create` and `device_create` to automatically create the device node under `/dev`, simplifying user interaction.\n*   **Basic File Operations:** Implements `open`, `release`, `read`, and `write`.\n*   **Synchronization:** Uses a `mutex` to protect the internal buffer from race conditions during concurrent access.\n*   **Error Handling:** Robust error checking with `goto` jumps for proper cleanup.\n*   **Kernel Coding Standards:** Adheres to common kernel style (indentation, comments, `printk` levels, `THIS_MODULE`, etc.).\n\n---\n\n### `mydev.c` (The Device Driver)\n\n```c\n#include <linux/module.h>     // Required for all kernel modules\n#include <linux/kernel.h>     // KERN_INFO\n#include <linux/init.h>       // __init, __exit macros\n#include <linux/fs.h>         // File operations, register_chrdev_region\n#include <linux/cdev.h>       // cdev_init, cdev_add, cdev_del\n#include <linux/device.h>     // class_create, device_create, device_destroy, class_destroy\n#include <linux/slab.h>       // kmalloc, kfree\n#include <linux/uaccess.h>    // copy_to_user, copy_from_user\n#include <linux/mutex.h>      // Mutex for synchronization\n\n#define MYDEV_NAME      \"mydev\"\n#define MYDEV_CLASS     \"mydev_class\"\n#define MYDEV_BUF_SIZE  1024  // Size of our internal buffer\n\n/*\n * Device private data structure\n */\nstruct mydev_data {\n    char        *buffer;              // The device's data buffer\n    size_t       buffer_size;         // Total size of the buffer\n    loff_t       current_offset;      // Current read/write offset (simple per-file-descriptor offset)\n    struct mutex mydev_mutex;        // Mutex to protect buffer access\n};\n\n/* Global variables for the device */\nstatic dev_t            mydev_num;       // Device number (major | minor)\nstatic struct cdev      mydev_cdev;      // Character device structure\nstatic struct class    *mydev_class;     // Device class for automatic /dev entry\n\n/*\n * Forward declarations for file operations\n */\nstatic int mydev_open(struct inode *inode, struct file *file);\nstatic int mydev_release(struct inode *inode, struct file *file);\nstatic ssize_t mydev_read(struct file *file, char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t mydev_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos);\nstatic loff_t mydev_llseek(struct file *file, loff_t offset, int whence);\n\n/*\n * File operations structure\n */\nstatic const struct file_operations mydev_fops = {\n    .owner   = THIS_MODULE,\n    .open    = mydev_open,\n    .release = mydev_release,\n    .read    = mydev_read,\n    .write   = mydev_write,\n    .llseek  = mydev_llseek,\n};\n\n/*\n * mydev_open: Called when a user application opens the device file.\n */\nstatic int mydev_open(struct inode *inode, struct file *file)\n{\n    struct mydev_data *dev_data;\n\n    // Get the private data structure from the cdev (stored by cdev_add)\n    dev_data = container_of(inode->i_cdev, struct mydev_data, mydev_cdev);\n\n    // Store the private data in file->private_data for later use by other fops\n    file->private_data = dev_data;\n\n    // Reset the offset for a new open (optional, depends on desired behavior)\n    // Here, each open starts reading/writing from the beginning.\n    // If you want shared offset, move current_offset into global/shared struct.\n    dev_data->current_offset = 0; \n\n    // Acquire the mutex\n    if (mutex_lock_interruptible(&dev_data->mydev_mutex)) {\n        printk(KERN_ERR \"%s: Could not acquire mutex on open.\\n\", MYDEV_NAME);\n        return -ERESTARTSYS; // Signal to restart the system call if interrupted\n    }\n\n    printk(KERN_INFO \"%s: Device opened (minor %d).\\n\", MYDEV_NAME, MINOR(inode->i_rdev));\n    mutex_unlock(&dev_data->mydev_mutex); // Release the mutex\n\n    return 0;\n}\n\n/*\n * mydev_release: Called when the last user application closes the device file.\n */\nstatic int mydev_release(struct inode *inode, struct file *file)\n{\n    struct mydev_data *dev_data = file->private_data;\n\n    // Acquire the mutex (optional for release, but good practice if state is modified)\n    if (mutex_lock_interruptible(&dev_data->mydev_mutex)) {\n        printk(KERN_ERR \"%s: Could not acquire mutex on release.\\n\", MYDEV_NAME);\n        return -ERESTARTSYS;\n    }\n\n    printk(KERN_INFO \"%s: Device closed (minor %d).\\n\", MYDEV_NAME, MINOR(inode->i_rdev));\n    mutex_unlock(&dev_data->mydev_mutex);\n\n    return 0;\n}\n\n/*\n * mydev_read: Called when a user application reads from the device file.\n */\nstatic ssize_t mydev_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n    struct mydev_data *dev_data = file->private_data;\n    ssize_t bytes_read = 0;\n    loff_t offset = *ppos;\n\n    if (mutex_lock_interruptible(&dev_data->mydev_mutex)) {\n        return -ERESTARTSYS;\n    }\n\n    // Ensure we don't read past the end of our buffer\n    if (offset >= dev_data->buffer_size) {\n        printk(KERN_INFO \"%s: Read past end of buffer.\\n\", MYDEV_NAME);\n        goto out; // Nothing to read\n    }\n\n    // Determine how many bytes we can actually read\n    if (count > (dev_data->buffer_size - offset)) {\n        count = dev_data->buffer_size - offset;\n    }\n\n    // Copy data from kernel space to user space\n    if (copy_to_user(buf, dev_data->buffer + offset, count)) {\n        printk(KERN_ERR \"%s: Failed to copy data to user space.\\n\", MYDEV_NAME);\n        bytes_read = -EFAULT; // Bad address\n        goto out;\n    }\n\n    offset += count;\n    bytes_read = count;\n    *ppos = offset; // Update the file position\n\n    printk(KERN_INFO \"%s: Read %zu bytes from offset %lld.\\n\", MYDEV_NAME, bytes_read, *ppos - bytes_read);\n\nout:\n    mutex_unlock(&dev_data->mydev_mutex);\n    return bytes_read;\n}\n\n/*\n * mydev_write: Called when a user application writes to the device file.\n */\nstatic ssize_t mydev_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n    struct mydev_data *dev_data = file->private_data;\n    ssize_t bytes_written = 0;\n    loff_t offset = *ppos;\n\n    if (mutex_lock_interruptible(&dev_data->mydev_mutex)) {\n        return -ERESTARTSYS;\n    }\n\n    // Ensure we don't write past the end of our buffer\n    if (offset >= dev_data->buffer_size) {\n        printk(KERN_INFO \"%s: Write past end of buffer (offset %lld >= size %zu).\\n\", MYDEV_NAME, offset, dev_data->buffer_size);\n        goto out; // No space to write\n    }\n\n    // Determine how many bytes we can actually write\n    if (count > (dev_data->buffer_size - offset)) {\n        printk(KERN_WARNING \"%s: Truncating write: requested %zu bytes, only %zu available.\\n\",\n               MYDEV_NAME, count, dev_data->buffer_size - offset);\n        count = dev_data->buffer_size - offset;\n    }\n\n    // Copy data from user space to kernel space\n    if (copy_from_user(dev_data->buffer + offset, buf, count)) {\n        printk(KERN_ERR \"%s: Failed to copy data from user space.\\n\", MYDEV_NAME);\n        bytes_written = -EFAULT; // Bad address\n        goto out;\n    }\n\n    offset += count;\n    bytes_written = count;\n    *ppos = offset; // Update the file position\n\n    printk(KERN_INFO \"%s: Written %zu bytes to offset %lld.\\n\", MYDEV_NAME, bytes_written, *ppos - bytes_written);\n\nout:\n    mutex_unlock(&dev_data->mydev_mutex);\n    return bytes_written;\n}\n\n/*\n * mydev_llseek: Adjust the file position.\n */\nstatic loff_t mydev_llseek(struct file *file, loff_t offset, int whence)\n{\n    struct mydev_data *dev_data = file->private_data;\n    loff_t new_pos;\n\n    if (mutex_lock_interruptible(&dev_data->mydev_mutex)) {\n        return -ERESTARTSYS;\n    }\n\n    switch (whence) {\n        case SEEK_SET: // From beginning of file\n            new_pos = offset;\n            break;\n        case SEEK_CUR: // From current position\n            new_pos = file->f_pos + offset;\n            break;\n        case SEEK_END: // From end of file (buffer size)\n            new_pos = dev_data->buffer_size + offset;\n            break;\n        default:\n            mutex_unlock(&dev_data->mydev_mutex);\n            return -EINVAL; // Invalid whence\n    }\n\n    // Ensure the new position is within valid bounds\n    if (new_pos < 0 || new_pos > dev_data->buffer_size) {\n        printk(KERN_WARNING \"%s: Invalid seek offset %lld (whence %d), buffer size %zu.\\n\",\n               MYDEV_NAME, offset, whence, dev_data->buffer_size);\n        mutex_unlock(&dev_data->mydev_mutex);\n        return -EINVAL; // Invalid argument\n    }\n\n    file->f_pos = new_pos;\n    printk(KERN_INFO \"%s: Seeked to position %lld.\\n\", MYDEV_NAME, new_pos);\n    mutex_unlock(&dev_data->mydev_mutex);\n    return new_pos;\n}\n\n/*\n * mydev_init: Called when the module is loaded.\n */\nstatic int __init mydev_init(void)\n{\n    int ret;\n    struct mydev_data *dev_data;\n\n    printk(KERN_INFO \"%s: Initializing the device driver.\\n\", MYDEV_NAME);\n\n    // 1. Allocate a major and minor number dynamically\n    ret = alloc_chrdev_region(&mydev_num, 0, 1, MYDEV_NAME);\n    if (ret < 0) {\n        printk(KERN_ERR \"%s: Failed to allocate character device region.\\n\", MYDEV_NAME);\n        return ret;\n    }\n    printk(KERN_INFO \"%s: Allocated device number Major: %d, Minor: %d.\\n\",\n           MYDEV_NAME, MAJOR(mydev_num), MINOR(mydev_num));\n\n    // 2. Create a device class (for automatic /dev entry creation)\n    mydev_class = class_create(THIS_MODULE, MYDEV_CLASS);\n    if (IS_ERR(mydev_class)) {\n        printk(KERN_ERR \"%s: Failed to create device class.\\n\", MYDEV_NAME);\n        ret = PTR_ERR(mydev_class);\n        goto err_unregister_chrdev;\n    }\n\n    // 3. Allocate memory for device private data\n    dev_data = kmalloc(sizeof(*dev_data), GFP_KERNEL);\n    if (!dev_data) {\n        printk(KERN_ERR \"%s: Failed to allocate device data structure.\\n\", MYDEV_NAME);\n        ret = -ENOMEM;\n        goto err_destroy_class;\n    }\n    memset(dev_data, 0, sizeof(*dev_data)); // Initialize to zeros\n\n    // 4. Allocate memory for the device buffer\n    dev_data->buffer = kmalloc(MYDEV_BUF_SIZE, GFP_KERNEL);\n    if (!dev_data->buffer) {\n        printk(KERN_ERR \"%s: Failed to allocate device buffer.\\n\", MYDEV_NAME);\n        ret = -ENOMEM;\n        goto err_free_dev_data;\n    }\n    dev_data->buffer_size = MYDEV_BUF_SIZE;\n    memset(dev_data->buffer, 0, MYDEV_BUF_SIZE); // Initialize buffer to zeros\n\n    // 5. Initialize the mutex\n    mutex_init(&dev_data->mydev_mutex);\n\n    // 6. Initialize and add the character device\n    cdev_init(&mydev_cdev, &mydev_fops);\n    mydev_cdev.owner = THIS_MODULE;\n    // Store our private data within the cdev structure itself\n    // This allows mydev_open to retrieve it using container_of\n    mydev_cdev.private_data = dev_data; \n\n    ret = cdev_add(&mydev_cdev, mydev_num, 1);\n    if (ret < 0) {\n        printk(KERN_ERR \"%s: Failed to add character device.\\n\", MYDEV_NAME);\n        goto err_free_buffer;\n    }\n\n    // 7. Create the device node in /dev (e.g., /dev/mydev)\n    if (IS_ERR(device_create(mydev_class, NULL, mydev_num, NULL, MYDEV_NAME))) {\n        printk(KERN_ERR \"%s: Failed to create device node.\\n\", MYDEV_NAME);\n        ret = PTR_ERR(device_create(mydev_class, NULL, mydev_num, NULL, MYDEV_NAME));\n        goto err_del_cdev;\n    }\n\n    printk(KERN_INFO \"%s: Device driver loaded successfully.\\n\", MYDEV_NAME);\n    return 0;\n\nerr_del_cdev:\n    cdev_del(&mydev_cdev);\nerr_free_buffer:\n    kfree(dev_data->buffer);\nerr_free_dev_data:\n    kfree(dev_data);\nerr_destroy_class:\n    class_destroy(mydev_class);\nerr_unregister_chrdev:\n    unregister_chrdev_region(mydev_num, 1);\n    return ret;\n}\n\n/*\n * mydev_exit: Called when the module is unloaded.\n */\nstatic void __exit mydev_exit(void)\n{\n    struct mydev_data *dev_data = (struct mydev_data *)mydev_cdev.private_data;\n\n    printk(KERN_INFO \"%s: Unloading the device driver.\\n\", MYDEV_NAME);\n\n    // 1. Destroy the device node\n    device_destroy(mydev_class, mydev_num);\n\n    // 2. Delete the character device\n    cdev_del(&mydev_cdev);\n\n    // 3. Destroy the device class\n    class_destroy(mydev_class);\n\n    // 4. Free the allocated buffer and device data structure\n    if (dev_data) { // Check if dev_data was successfully allocated\n        if (dev_data->buffer) {\n            kfree(dev_data->buffer);\n        }\n        kfree(dev_data);\n    }\n\n    // 5. Unregister the character device region\n    unregister_chrdev_region(mydev_num, 1);\n\n    printk(KERN_INFO \"%s: Device driver unloaded.\\n\", MYDEV_NAME);\n}\n\n// Module entry and exit points\nmodule_init(mydev_init);\nmodule_exit(mydev_exit);\n\n// Module metadata\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name/Company\");\nMODULE_DESCRIPTION(\"A simple character device driver example.\");\nMODULE_VERSION(\"0.1\");\n```\n\n---\n\n### `Makefile` (For Compiling the Driver)\n\n```makefile\n# Kernel module compilation\nobj-m += mydev.o\n\n# Specify the directory of the kernel source (replace with your kernel source path)\n# KERNEL_SRC ?= /lib/modules/$(shell uname -r)/build\nKERNEL_SRC ?= /usr/src/linux-headers-$(shell uname -r) # Common for Debian/Ubuntu\n\nall:\n\tmake -C $(KERNEL_SRC) M=$(PWD) modules\n\nclean:\n\tmake -C $(KERNEL_SRC) M=$(PWD) clean\n```\n\n---\n\n### How to Compile, Load, and Test:\n\n1.  **Save the files:**\n    *   `mydev.c`\n    *   `Makefile`\n\n2.  **Compile the module:**\n    ```bash\n    make\n    ```\n    This will produce `mydev.ko`.\n\n3.  **Load the module:**\n    You need root privileges for this.\n    ```bash\n    sudo insmod mydev.ko\n    ```\n    Check `dmesg` output:\n    ```bash\n    dmesg | grep mydev\n    ```\n    You should see messages like:\n    `mydev: Initializing the device driver.`\n    `mydev: Allocated device number Major: 24X, Minor: 0.` (The major number will vary)\n    `mydev: Device driver loaded successfully.`\n\n    Also, check for the device node:\n    ```bash\n    ls -l /dev/mydev\n    ```\n    You should see something like:\n    `crw-rw---- 1 root root 24X, 0 Mmm D HH:MM /dev/mydev`\n\n4.  **Test the device (using shell commands):**\n\n    *   **Write to the device:**\n        ```bash\n        echo \"Hello from user space!\" > /dev/mydev\n        ```\n        Check `dmesg`:\n        `mydev: Device opened (minor 0).`\n        `mydev: Written 23 bytes to offset 0.`\n        `mydev: Device closed (minor 0).`\n\n    *   **Read from the device:**\n        ```bash\n        cat /dev/mydev\n        ```\n        Output: `Hello from user space!`\n        Check `dmesg`:\n        `mydev: Device opened (minor 0).`\n        `mydev: Read 23 bytes from offset 0.`\n        `mydev: Device closed (minor 0).`\n\n    *   **Write more data (overwrites previous):**\n        ```bash\n        echo \"This is a longer message that will fill more of the buffer, exceeding the previous one.\" > /dev/mydev\n        cat /dev/mydev\n        ```\n        Output: `This is a longer message that will fill more of the buffer, exceeding the previous one.`\n        (The buffer size is 1024 bytes, so this should fit.)\n\n    *   **Test `seek` (e.g., read only part):**\n        ```bash\n        echo \"ABCDEFGHIJ\" > /dev/mydev\n        dd if=/dev/mydev of=/tmp/output.txt bs=1 count=3 skip=2 2>/dev/null\n        cat /tmp/output.txt\n        ```\n        Output: `CDE`\n        (Writes \"ABCDEFGHIJ\", then reads 3 bytes starting from offset 2)\n\n5.  **Unload the module:**\n    ```bash\n    sudo rmmod mydev\n    ```\n    Check `dmesg`:\n    `mydev: Unloading the device driver.`\n    `mydev: Device driver unloaded.`\n\n---\n\n**Important Considerations:**\n\n*   **Error Handling:** The driver includes basic error handling. In a real-world scenario, you'd want more specific error codes and logging.\n*   **Concurrency:** The `mutex` protects the `mydev_data` structure and its buffer. Without it, concurrent `read`/`write` operations from multiple processes could lead to data corruption.\n*   **`f_pos` vs. `ppos`:** `file->f_pos` is the current file position for that specific open file descriptor. `ppos` (passed to `read`/`write`) is a pointer to this `file->f_pos` and must be updated by the driver.\n*   **Buffer Management:** For a real device, the buffer might be much larger, require different allocation strategies (e.g., `vmalloc` for very large buffers), or involve DMA. This example uses a simple `kmalloc` buffer.\n*   **IOCTLs:** For more complex device control (e.g., changing device modes, clearing buffer, getting statistics), you would implement the `unlocked_ioctl` file operation.\n*   **Blocking vs. Non-blocking I/O:** This driver uses blocking I/O. For non-blocking behavior, you'd typically check `file->f_flags & O_NONBLOCK` and return `-EAGAIN` if data isn't ready or the buffer is full.\n*   **Poll/Select:** For asynchronous I/O, you'd implement the `poll` file operation."
        }
    },
    "2Implement a character device driver with basic read/write operations.": {
        "gemini-1.5-flash": {
            "success": true,
            "code": "```c\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\n#define DEVICE_NAME \"mychardev\"\n#define CLASS_NAME  \"mychardev_class\"\n\nstatic int major_num;\nstatic struct class *mychardev_class = NULL;\nstatic struct cdev mychardev_cdev;\nstatic char *buffer;\nstatic size_t buffer_size = 4096; // Adjust buffer size as needed\n\nstatic int mychardev_open(struct inode *inode, struct file *filp) {\n    pr_info(\"mychardev: opened\\n\");\n    return 0;\n}\n\nstatic int mychardev_release(struct inode *inode, struct file *filp) {\n    pr_info(\"mychardev: released\\n\");\n    return 0;\n}\n\nstatic ssize_t mychardev_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos) {\n    size_t bytes_to_read = min(count, buffer_size - *f_pos);\n    if (bytes_to_read == 0) return 0; //Nothing to read\n\n    if (copy_to_user(buf, buffer + *f_pos, bytes_to_read) != 0) {\n        pr_err(\"mychardev: copy_to_user failed\\n\");\n        return -EFAULT;\n    }\n\n    *f_pos += bytes_to_read;\n    return bytes_to_read;\n}\n\n\nstatic ssize_t mychardev_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos) {\n    size_t bytes_to_write = min(count, buffer_size - *f_pos);\n    if (bytes_to_write == 0) return 0; //Nowhere to write\n\n    if (copy_from_user(buffer + *f_pos, buf, bytes_to_write) != 0) {\n        pr_err(\"mychardev: copy_from_user failed\\n\");\n        return -EFAULT;\n    }\n\n    *f_pos += bytes_to_write;\n    return bytes_to_write;\n}\n\n\nstatic const struct file_operations mychardev_fops = {\n    .owner = THIS_MODULE,\n    .open = mychardev_open,\n    .release = mychardev_release,\n    .read = mychardev_read,\n    .write = mychardev_write,\n};\n\nstatic int __init mychardev_init(void) {\n    int ret;\n    dev_t dev;\n\n    ret = alloc_chrdev_region(&dev, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        pr_err(\"mychardev: failed to allocate major number\\n\");\n        return ret;\n    }\n    major_num = MAJOR(dev);\n\n    buffer = kmalloc(buffer_size, GFP_KERNEL);\n    if(!buffer){\n        pr_err(\"mychardev: failed to allocate buffer memory\\n\");\n        unregister_chrdev_region(dev, 1);\n        return -ENOMEM;\n    }\n\n    cdev_init(&mychardev_cdev, &mychardev_fops);\n    ret = cdev_add(&mychardev_cdev, dev, 1);\n    if (ret < 0) {\n        pr_err(\"mychardev: failed to add cdev\\n\");\n        kfree(buffer);\n        unregister_chrdev_region(dev, 1);\n        return ret;\n    }\n\n    mychardev_class = class_create(THIS_MODULE, CLASS_NAME);\n    if (IS_ERR(mychardev_class)) {\n        pr_err(\"mychardev: failed to create class\\n\");\n        cdev_del(&mychardev_cdev);\n        kfree(buffer);\n        unregister_chrdev_region(dev, 1);\n        return PTR_ERR(mychardev_class);\n    }\n\n    device_create(mychardev_class, NULL, dev, NULL, DEVICE_NAME);\n    pr_info(\"mychardev: driver loaded, major number %d\\n\", major_num);\n    return 0;\n}\n\nstatic void __exit mychardev_exit(void) {\n    dev_t dev = MKDEV(major_num, 0);\n    device_destroy(mychardev_class, dev);\n    class_unregister(mychardev_class);\n    class_destroy(mychardev_class);\n    cdev_del(&mychardev_cdev);\n    kfree(buffer);\n    unregister_chrdev_region(dev, 1);\n    pr_info(\"mychardev: driver unloaded\\n\");\n}\n\nmodule_init(mychardev_init);\nmodule_exit(mychardev_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Bard\");\nMODULE_DESCRIPTION(\"A simple character device driver\");\n```\n\nThis improved version includes:\n\n* **Error Handling:**  Thorough error checking at each step, returning appropriate error codes.\n* **Memory Management:** Uses `kmalloc` and `kfree` for kernel memory allocation and deallocation.  Handles allocation failures gracefully.\n* **Clearer Comments:** More descriptive comments explaining the code's purpose.\n* **Buffer Management:** Uses a kernel buffer to store data.  The `buffer_size` is configurable.\n* **Module Information:**  Includes `MODULE_LICENSE`, `MODULE_AUTHOR`, and `MODULE_DESCRIPTION` macros.\n* **`min()` usage:** Prevents buffer overflows by using `min()` to limit the number of bytes copied in `read` and `write` operations.\n* **Robust `read` and `write`:** Handles the case where nothing is to be read or written more efficiently.\n\nRemember to compile this code using a suitable kernel build system (like make) and install it into your kernel.  Always test device drivers thoroughly in a controlled environment before deploying them to production systems.  This example provides a foundation; you might need to add features like non-blocking I/O, ioctls, etc., depending on your requirements.\n"
        },
        "gemini-2.5-flash": {
            "success": true,
            "code": "Okay, here's a clean, production-quality Linux character device driver with basic read/write operations. It includes proper module structure, error handling, memory management, and uses a mutex for synchronization to protect the internal buffer.\n\n### `mychar_driver.c`\n\n```c\n#include <linux/module.h>       // Required for all kernel modules\n#include <linux/kernel.h>       // Required for KERN_INFO\n#include <linux/fs.h>           // Required for file_operations, register_chrdev_region, etc.\n#include <linux/cdev.h>         // Required for cdev structures\n#include <linux/device.h>       // Required for class_create, device_create\n#include <linux/slab.h>         // Required for kmalloc/kfree\n#include <linux/uaccess.h>      // Required for copy_to_user, copy_from_user\n#include <linux/mutex.h>        // Required for mutex synchronization\n\n// --- Module Metadata ---\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name/Company\");\nMODULE_DESCRIPTION(\"A simple character device driver with basic read/write.\");\nMODULE_VERSION(\"0.1\");\n\n// --- Device Constants ---\n#define MYCHAR_DEV_NAME     \"mychar_device\" // Name for the device\n#define MYCHAR_MINOR_COUNT  1               // Number of minor devices\n#define MYCHAR_BUF_SIZE     1024            // Size of the internal buffer in bytes\n\n// --- Global Variables ---\nstatic dev_t g_mychar_dev_num;              // Stores the major and minor numbers\nstatic struct cdev g_mychar_cdev;           // Character device structure\nstatic struct class *g_mychar_class;        // Device class for /sys/class/MYCHAR_DEV_NAME\nstatic char *g_mychar_buffer;               // Pointer to the device's internal buffer\nstatic size_t g_mychar_data_len = 0;        // Current amount of data in the buffer\nstatic DEFINE_MUTEX(g_mychar_mutex);        // Mutex for synchronizing access to g_mychar_buffer\n\n// --- Function Prototypes for file_operations ---\nstatic int mychar_open(struct inode *inode, struct file *file);\nstatic int mychar_release(struct inode *inode, struct file *file);\nstatic ssize_t mychar_read(struct file *file, char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t mychar_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos);\n\n// --- file_operations Structure ---\nstatic const struct file_operations mychar_fops = {\n    .owner   = THIS_MODULE,\n    .open    = mychar_open,\n    .release = mychar_release,\n    .read    = mychar_read,\n    .write   = mychar_write,\n    // No lseek, llseek will default to E_PIPE for character devices unless explicitly defined.\n    // This driver behaves like a simple stream/fifo, so ppos is used but data is consumed/appended.\n};\n\n// --- mychar_open: Called when a user application opens the device file ---\nstatic int mychar_open(struct inode *inode, struct file *file)\n{\n    // In this simple driver, we don't need to do much on open.\n    // For more complex drivers, you might initialize device state,\n    // check permissions, or manage device access counters.\n    pr_info(\"%s: Device opened.\\n\", MYCHAR_DEV_NAME);\n    return 0;\n}\n\n// --- mychar_release: Called when a user application closes the device file ---\nstatic int mychar_release(struct inode *inode, struct file *file)\n{\n    // Similar to open, often simple for basic drivers.\n    pr_info(\"%s: Device closed.\\n\", MYCHAR_DEV_NAME);\n    return 0;\n}\n\n// --- mychar_read: Called when a user application reads from the device file ---\nstatic ssize_t mychar_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n    ssize_t bytes_to_read = 0;\n    unsigned long bytes_not_copied;\n\n    // Acquire the mutex to protect the buffer during read\n    if (mutex_lock_interruptible(&g_mychar_mutex))\n        return -ERESTARTSYS; // Interrupted by a signal\n\n    // Determine how many bytes can actually be read\n    // We start reading from the beginning of the available data (g_mychar_buffer)\n    // and respect the user's requested 'count'.\n    // The *ppos is generally used for byte offset into the file. For a stream device,\n    // often it's ignored or implies a read from the current logical position.\n    // For this simple buffer, we'll read from the current effective beginning (offset 0)\n    // and consume data by shifting. This makes it behave like a FIFO/pipe.\n\n    if (g_mychar_data_len == 0) {\n        pr_debug(\"%s: Read: No data available to read.\\n\", MYCHAR_DEV_NAME);\n        mutex_unlock(&g_mychar_mutex);\n        return 0; // No data currently in the buffer\n    }\n\n    // bytes_to_read will be the minimum of user's requested count and available data\n    bytes_to_read = min((size_t)count, g_mychar_data_len);\n\n    // Copy data from kernel buffer to user buffer\n    bytes_not_copied = copy_to_user(buf, g_mychar_buffer, bytes_to_read);\n    if (bytes_not_copied) {\n        pr_err(\"%s: Failed to copy %lu bytes to user space during read.\\n\",\n               MYCHAR_DEV_NAME, bytes_not_copied);\n        mutex_unlock(&g_mychar_mutex);\n        return -EFAULT; // Bad address\n    }\n\n    // Consume the data by shifting the remaining data to the beginning of the buffer\n    if (g_mychar_data_len > bytes_to_read) {\n        memmove(g_mychar_buffer, g_mychar_buffer + bytes_to_read, g_mychar_data_len - bytes_to_read);\n    }\n    g_mychar_data_len -= bytes_to_read; // Update the effective data length\n\n    // Update the file position (though for stream devices, this is often irrelevant conceptually)\n    // *ppos += bytes_to_read; // For a simple char device, this is often ignored or not directly tied to buffer offset.\n\n    pr_info(\"%s: Read %zd bytes (requested %zu).\\n\", MYCHAR_DEV_NAME, bytes_to_read, count);\n\n    mutex_unlock(&g_mychar_mutex);\n    return bytes_to_read; // Return the number of bytes actually read\n}\n\n// --- mychar_write: Called when a user application writes to the device file ---\nstatic ssize_t mychar_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n    ssize_t bytes_to_write = 0;\n    unsigned long bytes_not_copied;\n\n    // Acquire the mutex to protect the buffer during write\n    if (mutex_lock_interruptible(&g_mychar_mutex))\n        return -ERESTARTSYS; // Interrupted by a signal\n\n    // Determine how many bytes can actually be written (space available)\n    // We append new data to the end of the existing data in the buffer.\n    size_t space_available = MYCHAR_BUF_SIZE - g_mychar_data_len;\n\n    if (space_available == 0) {\n        pr_warn(\"%s: Write: Buffer is full, cannot write more data.\\n\", MYCHAR_DEV_NAME);\n        mutex_unlock(&g_mychar_mutex);\n        return -ENOSPC; // No space left on device\n    }\n\n    // bytes_to_write will be the minimum of user's requested count and available space\n    bytes_to_write = min((size_t)count, space_available);\n\n    // Copy data from user buffer to kernel buffer, appending to the end\n    bytes_not_copied = copy_from_user(g_mychar_buffer + g_mychar_data_len, buf, bytes_to_write);\n    if (bytes_not_copied) {\n        pr_err(\"%s: Failed to copy %lu bytes from user space during write.\\n\",\n               MYCHAR_DEV_NAME, bytes_not_copied);\n        mutex_unlock(&g_mychar_mutex);\n        return -EFAULT; // Bad address\n    }\n\n    g_mychar_data_len += bytes_to_write; // Update the effective data length\n\n    // Update the file position\n    // *ppos += bytes_to_write; // For a simple char device, this is often ignored or not directly tied to buffer offset.\n\n    pr_info(\"%s: Written %zd bytes (requested %zu).\\n\", MYCHAR_DEV_NAME, bytes_to_write, count);\n\n    mutex_unlock(&g_mychar_mutex);\n    return bytes_to_write; // Return the number of bytes actually written\n}\n\n// --- Module Initialization Function ---\nstatic int __init mychar_init(void)\n{\n    int ret;\n\n    pr_info(\"%s: Initializing module...\\n\", MYCHAR_DEV_NAME);\n\n    // 1. Allocate a character device region dynamically\n    // The 0 indicates the first minor number, MYCHAR_MINOR_COUNT for the number of minors.\n    ret = alloc_chrdev_region(&g_mychar_dev_num, 0, MYCHAR_MINOR_COUNT, MYCHAR_DEV_NAME);\n    if (ret < 0) {\n        pr_err(\"%s: Failed to allocate character device region: %d\\n\", MYCHAR_DEV_NAME, ret);\n        return ret;\n    }\n    pr_info(\"%s: Allocated major %d, minor %d.\\n\", MYCHAR_DEV_NAME,\n            MAJOR(g_mychar_dev_num), MINOR(g_mychar_dev_num));\n\n    // 2. Initialize the cdev structure and connect it to file_operations\n    cdev_init(&g_mychar_cdev, &mychar_fops);\n    g_mychar_cdev.owner = THIS_MODULE; // Set the owner of the cdev to this module\n\n    // 3. Add the cdev to the system\n    ret = cdev_add(&g_mychar_cdev, g_mychar_dev_num, MYCHAR_MINOR_COUNT);\n    if (ret < 0) {\n        pr_err(\"%s: Failed to add cdev: %d\\n\", MYCHAR_DEV_NAME, ret);\n        goto err_cdev_add;\n    }\n\n    // 4. Create a device class for sysfs\n    g_mychar_class = class_create(THIS_MODULE, MYCHAR_DEV_NAME);\n    if (IS_ERR(g_mychar_class)) {\n        ret = PTR_ERR(g_mychar_class);\n        pr_err(\"%s: Failed to create device class: %d\\n\", MYCHAR_DEV_NAME, ret);\n        goto err_class_create;\n    }\n\n    // 5. Create the device file in /dev (udev will handle creation based on sysfs entry)\n    // This creates /dev/mychar_device\n    if (IS_ERR(device_create(g_mychar_class, NULL, g_mychar_dev_num, NULL, MYCHAR_DEV_NAME))) {\n        ret = PTR_ERR(device_create(g_mychar_class, NULL, g_mychar_dev_num, NULL, MYCHAR_DEV_NAME)); // Re-call to get error\n        pr_err(\"%s: Failed to create device file: %d\\n\", MYCHAR_DEV_NAME, ret);\n        goto err_device_create;\n    }\n\n    // 6. Allocate memory for the internal device buffer\n    g_mychar_buffer = kmalloc(MYCHAR_BUF_SIZE, GFP_KERNEL);\n    if (!g_mychar_buffer) {\n        pr_err(\"%s: Failed to allocate buffer memory.\\n\", MYCHAR_DEV_NAME);\n        ret = -ENOMEM;\n        goto err_kmalloc;\n    }\n    g_mychar_data_len = 0; // Initialize data length to 0\n\n    pr_info(\"%s: Module loaded successfully.\\n\", MYCHAR_DEV_NAME);\n    return 0; // Success\n\n// --- Error Handling Cleanup ---\nerr_kmalloc:\n    device_destroy(g_mychar_class, g_mychar_dev_num); // Destroy device if buffer alloc failed\nerr_device_create:\n    class_destroy(g_mychar_class); // Destroy class if device creation failed\nerr_class_create:\n    cdev_del(&g_mychar_cdev); // Delete cdev if class creation failed\nerr_cdev_add:\n    unregister_chrdev_region(g_mychar_dev_num, MYCHAR_MINOR_COUNT); // Unregister region if cdev_add failed\n    return ret;\n}\n\n// --- Module Exit Function ---\nstatic void __exit mychar_exit(void)\n{\n    pr_info(\"%s: Exiting module...\\n\", MYCHAR_DEV_NAME);\n\n    // 1. Destroy the device file\n    device_destroy(g_mychar_class, g_mychar_dev_num);\n\n    // 2. Destroy the device class\n    class_destroy(g_mychar_class);\n\n    // 3. Delete the cdev\n    cdev_del(&g_mychar_cdev);\n\n    // 4. Unregister the character device region\n    unregister_chrdev_region(g_mychar_dev_num, MYCHAR_MINOR_COUNT);\n\n    // 5. Free the allocated buffer memory\n    kfree(g_mychar_buffer);\n    g_mychar_buffer = NULL; // Clear pointer after freeing\n\n    pr_info(\"%s: Module unloaded.\\n\", MYCHAR_DEV_NAME);\n}\n\n// --- Module Entry/Exit Points ---\nmodule_init(mychar_init);\nmodule_exit(mychar_exit);\n```\n\n### `Makefile`\n\nTo compile this driver, you'll need a `Makefile`. Place it in the same directory as `mychar_driver.c`.\n\n```makefile\n# KERNELRELEASE is defined by the kernel's build system\nifeq ($(KERNELRELEASE),)\n\n# PATH_TO_KERNEL_SRC should point to your kernel source tree\n# For example: /lib/modules/$(shell uname -r)/build\n# It's usually safe to use $(shell uname -r) for current running kernel\nKERNEL_SRC := /lib/modules/$(shell uname -r)/build\nPWD := $(shell pwd)\n\nmodules:\n\t$(MAKE) -C $(KERNEL_SRC) M=$(PWD) modules\n\nmodules_install:\n\t$(MAKE) -C $(KERNEL_SRC) M=$(PWD) modules_install\n\nclean:\n\t$(MAKE) -C $(KERNEL_SRC) M=$(PWD) clean\n\trm -rf *.ko *.o *.mod.c *.symvers *.order .tmp_versions\n\n.PHONY: modules modules_install clean\n\nelse\n# Called from the kernel build system\nobj-m := mychar_driver.o\n\nendif\n```\n\n### How to Compile, Install, and Test\n\n1.  **Save the files:**\n    *   `mychar_driver.c`\n    *   `Makefile`\n    In the same directory, e.g., `~/mychar_driver/`.\n\n2.  **Compile the module:**\n    Navigate to the directory in your terminal and run `make`:\n    ```bash\n    cd ~/mychar_driver/\n    make\n    ```\n    This will produce `mychar_driver.ko`.\n\n3.  **Load the module:**\n    You'll need root privileges.\n    ```bash\n    sudo insmod mychar_driver.ko\n    ```\n    Check the kernel messages for output:\n    ```bash\n    dmesg | tail\n    # You should see something like:\n    # [XXXXX.XXXXXX] mychar_device: Initializing module...\n    # [XXXXX.XXXXXX] mychar_device: Allocated major X, minor 0.\n    # [XXXXX.XXXXXX] mychar_device: Module loaded successfully.\n    ```\n    Verify the device file:\n    ```bash\n    ls -l /dev/mychar_device\n    # Expected output: crw-rw-r-- 1 root root X, 0 <date> <time> /dev/mychar_device\n    # The 'c' indicates a character device. The 'X, 0' are major, minor numbers.\n    ```\n\n4.  **Test the device:**\n\n    *   **Write to the device:**\n        ```bash\n        echo \"Hello, Kernel World!\" > /dev/mychar_device\n        # Check dmesg for write messages:\n        # dmesg | tail\n        # You should see: mychar_device: Written 21 bytes (requested 21).\n        ```\n        Try writing more than the buffer size (`1024` bytes). You'll get `-ENOSPC` errors in `dmesg`.\n\n    *   **Read from the device:**\n        ```bash\n        cat /dev/mychar_device\n        # Expected output: Hello, Kernel World!\n        # Check dmesg for read messages:\n        # dmesg | tail\n        # You should see: mychar_device: Read 21 bytes (requested 131072).\n        ```\n        Since our `read` operation *consumes* data by shifting the buffer, if you `cat` again, you'll get nothing:\n        ```bash\n        cat /dev/mychar_device\n        # (No output)\n        # dmesg | tail\n        # You should see: mychar_device: Read: No data available to read.\n        ```\n        This demonstrates the FIFO-like behavior (First-In, First-Out).\n\n5.  **Unload the module:**\n    ```bash\n    sudo rmmod mychar_driver\n    ```\n    Check `dmesg` again:\n    ```bash\n    dmesg | tail\n    # You should see:\n    # [XXXXX.XXXXXX] mychar_device: Exiting module...\n    # [XXXXX.XXXXXX] mychar_device: Module unloaded.\n    ```\n    The `/dev/mychar_device` file should also be gone.\n\n### Key Aspects and Kernel Coding Standards Adherence:\n\n*   **Module Structure:** `module_init` and `module_exit` functions are used as entry and exit points.\n*   **Module Metadata:** `MODULE_LICENSE`, `MODULE_AUTHOR`, `MODULE_DESCRIPTION`, `MODULE_VERSION` are properly defined.\n*   **Character Device Registration:**\n    *   `alloc_chrdev_region` is used for dynamic major/minor number allocation, which is preferred over `register_chrdev_region` (static allocation).\n    *   `cdev_init` and `cdev_add` are used to initialize and register the `cdev` structure.\n*   **Automatic Device Node Creation:**\n    *   `class_create` and `device_create` are used. This is the modern and recommended way to create `/dev` entries, as `udev` (or `mdev` on embedded systems) will automatically create the device file when the module is loaded, and remove it when unloaded. This avoids manual `mknod`.\n*   **`file_operations`:** A `const struct file_operations` is defined with pointers to the handler functions (`open`, `release`, `read`, `write`). `THIS_MODULE` is assigned to `.owner`.\n*   **Error Handling:**\n    *   Every allocation/registration function returns an error code, which is checked.\n    *   A `goto` jump table is used in `mychar_init` to ensure proper rollback and cleanup of resources allocated *before* an error occurred. This prevents resource leaks if initialization fails.\n*   **Memory Management:**\n    *   `kmalloc` is used for allocating the kernel buffer, and `kfree` for freeing it.\n    *   `GFP_KERNEL` is used as the allocation flag, suitable for kernel code that might sleep.\n*   **Synchronization:**\n    *   A `struct mutex` (`g_mychar_mutex`) is used to protect the `g_mychar_buffer` from concurrent access during `read` and `write` operations. This is crucial for data integrity in a multi-threaded or multi-process environment. `mutex_lock_interruptible` is used, allowing the operation to be interrupted by signals.\n    *   `DEFINE_MUTEX` is a convenient macro for static mutexes.\n*   **User Space Communication:**\n    *   `copy_to_user` and `copy_from_user` are used for safe data transfer between kernel and user space. They return the number of bytes *not* copied, allowing for error checking.\n*   **Logging:** `pr_info`, `pr_err`, `pr_warn`, `pr_debug` are used for kernel logging, adhering to standard severity levels. `pr_debug` messages are conditional (require `CONFIG_DYNAMIC_DEBUG` or `_DEBUG` macro).\n*   **Buffer Behavior:** The `read` operation consumes data by shifting the buffer, making it behave like a simple FIFO or stream, which is typical for a character device. The `write` operation appends data.\n*   **`loff_t *ppos`:** While present in the function signatures, for this simple stream-like device, it's not strictly used for internal buffer indexing but is updated by the VFS layer based on the return value of `read`/`write`. If you wanted a seekable device, you'd manage `ppos` more directly as an offset into a conceptual buffer."
        }
    },
    "Create a kernel module that interacts with hardware.": {
        "gemini-1.5-flash": {
            "success": true,
            "code": "This example simulates interaction with hardware.  A real hardware driver would require specific hardware-dependent operations.  This example focuses on demonstrating proper kernel coding style and techniques for interacting with simulated hardware.\n\n```c\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/cdev.h>\n#include <linux/device.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Bard\");\nMODULE_DESCRIPTION(\"Simulated Hardware Driver\");\n\n#define DEVICE_NAME \"simulated_hw\"\n#define CLASS_NAME  \"simulated\"\n\nstatic dev_t dev;\nstatic struct cdev cdev;\nstatic struct class *class;\nstatic int major_num;\n\n// Simulated hardware register\nstatic unsigned int hw_register = 0;\n\nstatic int simulated_hw_open(struct inode *inode, struct file *file) {\n    pr_info(\"Simulated HW: Device opened\\n\");\n    return 0;\n}\n\nstatic int simulated_hw_release(struct inode *inode, struct file *file) {\n    pr_info(\"Simulated HW: Device released\\n\");\n    return 0;\n}\n\nstatic ssize_t simulated_hw_read(struct file *file, char __user *buf, size_t count, loff_t *f_pos) {\n    int ret;\n    unsigned int value = hw_register;\n\n    //Check for valid buffer\n    if (!buf) return -EINVAL;\n\n    //Simulate reading from hardware register\n    if (*f_pos >= sizeof(value)) {\n      return 0; //End of file\n    }\n\n    ret = copy_to_user(buf, &value, min(count, sizeof(value)));\n    if (ret) {\n        pr_err(\"Simulated HW: Failed to copy data to user space\\n\");\n        return -EFAULT;\n    }\n    *f_pos += sizeof(value);\n    return sizeof(value);\n\n}\n\n\nstatic ssize_t simulated_hw_write(struct file *file, const char __user *buf, size_t count, loff_t *f_pos) {\n    int ret;\n    unsigned int value;\n\n    //Check for valid buffer\n    if (!buf) return -EINVAL;\n\n\n    ret = copy_from_user(&value, buf, min(count, sizeof(value)));\n    if (ret) {\n        pr_err(\"Simulated HW: Failed to copy data from user space\\n\");\n        return -EFAULT;\n    }\n    hw_register = value;\n    pr_info(\"Simulated HW: Wrote value %u to register\\n\", hw_register);\n    *f_pos += count;\n    return count;\n}\n\n\nstatic const struct file_operations fops = {\n    .owner          = THIS_MODULE,\n    .open           = simulated_hw_open,\n    .release        = simulated_hw_release,\n    .read           = simulated_hw_read,\n    .write          = simulated_hw_write,\n};\n\n\nstatic int __init simulated_hw_init(void) {\n    int ret;\n\n    ret = alloc_chrdev_region(&dev, 0, 1, DEVICE_NAME);\n    if (ret < 0) {\n        pr_err(\"Simulated HW: Failed to allocate major number\\n\");\n        return ret;\n    }\n    major_num = MAJOR(dev);\n\n    cdev_init(&cdev, &fops);\n\n    ret = cdev_add(&cdev, dev, 1);\n    if (ret < 0) {\n        pr_err(\"Simulated HW: Failed to add cdev\\n\");\n        goto unregister_chrdev;\n    }\n\n    class = class_create(THIS_MODULE, CLASS_NAME);\n    if (IS_ERR(class)) {\n        pr_err(\"Simulated HW: Failed to create class\\n\");\n        ret = PTR_ERR(class);\n        goto remove_cdev;\n    }\n\n    if (device_create(class, NULL, dev, NULL, DEVICE_NAME) == NULL) {\n        pr_err(\"Simulated HW: Failed to create device\\n\");\n        ret = -ENOMEM;\n        goto destroy_class;\n    }\n\n    pr_info(\"Simulated HW: Module loaded with major number %d\\n\", major_num);\n    return 0;\n\n\ndestroy_class:\n    class_destroy(class);\nremove_cdev:\n    cdev_del(&cdev);\nunregister_chrdev:\n    unregister_chrdev_region(dev, 1);\n    return ret;\n}\n\nstatic void __exit simulated_hw_exit(void) {\n    device_destroy(class, dev);\n    class_destroy(class);\n    cdev_del(&cdev);\n    unregister_chrdev_region(dev, 1);\n    pr_info(\"Simulated HW: Module unloaded\\n\");\n}\n\nmodule_init(simulated_hw_init);\nmodule_exit(simulated_hw_exit);\n```\n\nRemember to compile this code using the correct kernel headers and build system (e.g., `make`).  This is a simplified example;  a production-ready driver would require more robust error handling,  handling of interrupts, DMA, and other hardware-specific operations depending on the target hardware.  Always thoroughly test any kernel module before deploying it to a production system.  Improperly written kernel modules can lead to system instability or crashes.\n"
        },
        "gemini-2.5-flash": {
            "success": true,
            "code": "Here's a Linux kernel module demonstrating interaction with simulated hardware.\n\nThis example simulates a simple memory-mapped device with:\n1.  **Memory-Mapped Registers (MMIO):** `CONTROL_REG`, `DATA_REG`, `STATUS_REG`, `IRQ_TRIGGER_REG`.\n2.  **Interrupt Handling:** A mechanism to wait for an interrupt (simulated via an MMIO write).\n3.  **Character Device Interface:** Exposes the \"hardware\" to user-space via `/dev/my_hw_dev` for read/write and `ioctl` operations.\n4.  **Platform Bus Integration:** Demonstrates how to register a `platform_driver` and `platform_device`, which is the standard way to manage integrated devices (e.g., SoC peripherals, devices described in Device Tree).\n\n**Key Concepts Demonstrated:**\n\n*   **Platform Device Model:** How drivers bind to devices and manage resources.\n*   **MMIO Access:** `ioremap_resource`, `ioread32`, `iowrite32`.\n*   **Interrupts:** `devm_request_irq`, `wait_for_completion_interruptible`, `complete`.\n*   **Character Device:** `cdev`, `file_operations`, `alloc_chrdev_region`, `device_create`.\n*   **User-Kernel Communication:** `copy_to_user`, `copy_from_user`, `ioctl` with custom commands.\n*   **Error Handling & Resource Management:** Using `devm_*` APIs for automatic cleanup and proper `goto` error handling.\n*   **Kernel Coding Standards:** Adherence to style, commenting, and logging.\n\n---\n\n**1. `my_hw_driver.c` (Kernel Module Source)**\n\n```c\n#include <linux/module.h>       // For module_init, module_exit\n#include <linux/platform_device.h> // For platform_driver, platform_device\n#include <linux/mod_devicetable.h> // For of_device_id\n#include <linux/io.h>           // For ioremap_resource, ioread32, iowrite32\n#include <linux/slab.h>         // For kmalloc, kfree\n#include <linux/fs.h>           // For file_operations, register_chrdev_region, etc.\n#include <linux/cdev.h>         // For cdev\n#include <linux/uaccess.h>      // For copy_to_user, copy_from_user\n#include <linux/interrupt.h>    // For IRQ_HANDLED, irq_handler_t, devm_request_irq\n#include <linux/completion.h>   // For completion mechanism\n#include <linux/delay.h>        // For mdelay (for simulation only)\n\n// --- Module Metadata ---\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Your Name/Company\");\nMODULE_DESCRIPTION(\"A simple kernel module interacting with simulated hardware.\");\nMODULE_VERSION(\"0.1\");\n\n// --- Simulated Hardware Register Offsets ---\n// These offsets represent addresses within the device's MMIO region.\n#define MY_HW_CONTROL_REG_OFFSET    0x00 // Control register (e.g., enable/disable)\n#define MY_HW_DATA_REG_OFFSET       0x04 // Data register (read/write data)\n#define MY_HW_STATUS_REG_OFFSET     0x08 // Status register (read-only, e.g., data ready)\n#define MY_HW_IRQ_TRIGGER_REG_OFFSET 0x0C // Write to this to trigger a simulated IRQ\n\n// --- IOCTL Commands ---\n// Define custom IOCTL commands for interaction\n#define MY_HW_IOC_MAGIC  'M' // Unique magic number\n#define MY_HW_IOC_SET_CONTROL  _IOW(MY_HW_IOC_MAGIC, 1, u32) // Set control register\n#define MY_HW_IOC_GET_CONTROL  _IOR(MY_HW_IOC_MAGIC, 2, u32) // Get control register\n#define MY_HW_IOC_GET_STATUS   _IOR(MY_HW_IOC_MAGIC, 3, u32) // Get status register\n#define MY_HW_IOC_TRIGGER_IRQ  _IO(MY_HW_IOC_MAGIC, 4)      // Trigger a simulated IRQ\n#define MY_HW_IOC_WAIT_FOR_IRQ _IO(MY_HW_IOC_MAGIC, 5)      // Wait for an IRQ event\n\n// --- Per-Device Private Data Structure ---\n// This structure holds all relevant data for a single instance of our simulated device.\nstruct my_hw_dev {\n    struct device        *dev;           // Pointer to the kernel device structure\n    void __iomem         *regs;          // Base address of mapped MMIO registers\n    int                   irq;           // IRQ number for this device\n    struct cdev           cdev;          // Character device structure\n    dev_t                 dev_num;       // Major/minor device number\n    struct class         *dev_class;     // Pointer to the device class\n\n    // Simulation-specific fields:\n    // For a real device, these might be internal hardware states.\n    u32                   control_reg_val;\n    u32                   status_reg_val;\n    u32                   data_reg_val;\n\n    struct completion     irq_completion; // Used to signal completion of an IRQ event\n};\n\n// Forward declarations for file operations\nstatic int my_hw_open(struct inode *inode, struct file *file);\nstatic int my_hw_release(struct inode *inode, struct file *file);\nstatic ssize_t my_hw_read(struct file *file, char __user *buf, size_t count, loff_t *ppos);\nstatic ssize_t my_hw_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos);\nstatic long my_hw_ioctl(struct file *file, unsigned int cmd, unsigned long arg);\n\n// --- File Operations Structure ---\nstatic const struct file_operations my_hw_fops = {\n    .owner          = THIS_MODULE,\n    .open           = my_hw_open,\n    .release        = my_hw_release,\n    .read           = my_hw_read,\n    .write          = my_hw_write,\n    .unlocked_ioctl = my_hw_ioctl,\n};\n\n// --- IRQ Handler (Simulated) ---\n// This function would be called by the kernel when the hardware asserts its IRQ line.\n// For our simulation, it's called programmatically when the 'IRQ_TRIGGER_REG' is written to.\nstatic irqreturn_t my_hw_isr(int irq, void *dev_id)\n{\n    struct my_hw_dev *priv = (struct my_hw_dev *)dev_id;\n\n    dev_info(priv->dev, \"IRQ received (simulated)! Completing wait.\\n\");\n\n    // In a real device, you'd typically read/clear hardware status registers here\n    // to acknowledge the interrupt and find its source.\n    // For simulation, we just complete the waiting process.\n    complete(&priv->irq_completion);\n\n    return IRQ_HANDLED;\n}\n\n// --- Character Device Operations Implementations ---\n\nstatic int my_hw_open(struct inode *inode, struct file *file)\n{\n    struct my_hw_dev *priv;\n\n    // Get our private data structure from the cdev structure\n    priv = container_of(inode->i_cdev, struct my_hw_dev, cdev);\n    file->private_data = priv; // Store it for other file operations\n\n    dev_info(priv->dev, \"Device opened.\\n\");\n    return 0;\n}\n\nstatic int my_hw_release(struct inode *inode, struct file *file)\n{\n    struct my_hw_dev *priv = (struct my_hw_dev *)file->private_data;\n\n    dev_info(priv->dev, \"Device closed.\\n\");\n    return 0;\n}\n\nstatic ssize_t my_hw_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)\n{\n    struct my_hw_dev *priv = (struct my_hw_dev *)file->private_data;\n    u32 data_to_read;\n    ssize_t retval = 0;\n\n    // Read the simulated DATA_REG.\n    // For a real device, you'd use ioread32(priv->regs + MY_HW_DATA_REG_OFFSET).\n    data_to_read = priv->data_reg_val;\n    dev_info(priv->dev, \"Reading DATA_REG: 0x%08X\\n\", data_to_read);\n\n    if (*ppos >= sizeof(u32))\n        return 0; // End of file for a single 32-bit read\n\n    if (count > sizeof(u32) - *ppos)\n        count = sizeof(u32) - *ppos;\n\n    if (copy_to_user(buf, &data_to_read, count)) {\n        dev_err(priv->dev, \"Failed to copy data to user space.\\n\");\n        return -EFAULT;\n    }\n\n    *ppos += count;\n    retval = count;\n\n    return retval;\n}\n\nstatic ssize_t my_hw_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)\n{\n    struct my_hw_dev *priv = (struct my_hw_dev *)file->private_data;\n    u32 data_to_write;\n    ssize_t retval = 0;\n\n    if (count < sizeof(u32)) {\n        dev_warn(priv->dev, \"Write size (%zu) too small, expecting %zu for DATA_REG.\\n\",\n                 count, sizeof(u32));\n        return -EINVAL;\n    }\n\n    if (copy_from_user(&data_to_write, buf, sizeof(u32))) {\n        dev_err(priv->dev, \"Failed to copy data from user space.\\n\");\n        return -EFAULT;\n    }\n\n    // Write to the simulated DATA_REG.\n    // For a real device, you'd use iowrite32(data_to_write, priv->regs + MY_HW_DATA_REG_OFFSET);\n    priv->data_reg_val = data_to_write;\n    dev_info(priv->dev, \"Writing 0x%08X to DATA_REG.\\n\", data_to_write);\n\n    *ppos += sizeof(u32);\n    retval = sizeof(u32);\n\n    return retval;\n}\n\nstatic long my_hw_ioctl(struct file *file, unsigned int cmd, unsigned long arg)\n{\n    struct my_hw_dev *priv = (struct my_hw_dev *)file->private_data;\n    long ret = 0;\n    u32 value;\n\n    if (_IOC_TYPE(cmd) != MY_HW_IOC_MAGIC)\n        return -ENOTTY; // Not a valid ioctl for this device\n\n    switch (cmd) {\n    case MY_HW_IOC_SET_CONTROL:\n        if (copy_from_user(&value, (u32 __user *)arg, sizeof(u32))) {\n            ret = -EFAULT;\n            break;\n        }\n        // Simulated write to CONTROL_REG\n        // Real: iowrite32(value, priv->regs + MY_HW_CONTROL_REG_OFFSET);\n        priv->control_reg_val = value;\n        dev_info(priv->dev, \"Set CONTROL_REG to 0x%08X\\n\", value);\n        break;\n\n    case MY_HW_IOC_GET_CONTROL:\n        // Simulated read from CONTROL_REG\n        // Real: value = ioread32(priv->regs + MY_HW_CONTROL_REG_OFFSET);\n        value = priv->control_reg_val;\n        if (copy_to_user((u32 __user *)arg, &value, sizeof(u32))) {\n            ret = -EFAULT;\n            break;\n        }\n        dev_info(priv->dev, \"Got CONTROL_REG: 0x%08X\\n\", value);\n        break;\n\n    case MY_HW_IOC_GET_STATUS:\n        // Simulated read from STATUS_REG\n        // Real: value = ioread32(priv->regs + MY_HW_STATUS_REG_OFFSET);\n        value = priv->status_reg_val;\n        if (copy_to_user((u32 __user *)arg, &value, sizeof(u32))) {\n            ret = -EFAULT;\n            break;\n        }\n        dev_info(priv->dev, \"Got STATUS_REG: 0x%08X\\n\", value);\n        break;\n\n    case MY_HW_IOC_TRIGGER_IRQ:\n        // Simulate a write to the IRQ_TRIGGER_REG which internally\n        // causes the \"hardware\" to raise an interrupt.\n        // In this simulation, writing to it directly calls the ISR logic.\n        // For a real device, you would just do iowrite32(1, priv->regs + MY_HW_IRQ_TRIGGER_REG_OFFSET);\n        // and the hardware would actually generate the IRQ.\n        dev_info(priv->dev, \"Triggering simulated IRQ via IOCTL.\\n\");\n        mdelay(1); // Simulate some delay\n        my_hw_isr(priv->irq, priv); // Directly call the ISR logic for simulation\n        break;\n\n    case MY_HW_IOC_WAIT_FOR_IRQ:\n        dev_info(priv->dev, \"Waiting for IRQ event...\\n\");\n        // Reinitialize the completion variable before waiting for a new event\n        reinit_completion(&priv->irq_completion);\n        // Wait for the IRQ handler to signal completion\n        if (wait_for_completion_interruptible(&priv->irq_completion)) {\n            dev_info(priv->dev, \"Wait for IRQ interrupted.\\n\");\n            ret = -ERESTARTSYS; // Signal that syscall needs to be restarted\n        } else {\n            dev_info(priv->dev, \"Wait for IRQ completed.\\n\");\n        }\n        break;\n\n    default:\n        dev_warn(priv->dev, \"Unknown IOCTL command 0x%x\\n\", cmd);\n        ret = -ENOTTY;\n        break;\n    }\n\n    return ret;\n}\n\n// --- Platform Driver Probe and Remove Functions ---\n\nstatic int my_hw_probe(struct platform_device *pdev)\n{\n    struct my_hw_dev *priv;\n    struct resource *res_mem, *res_irq;\n    int ret = 0;\n\n    dev_info(&pdev->dev, \"Probe function called for %s.\\n\", pdev->name);\n\n    // 1. Allocate and initialize private data structure\n    priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);\n    if (!priv) {\n        dev_err(&pdev->dev, \"Failed to allocate private data.\\n\");\n        return -ENOMEM;\n    }\n\n    priv->dev = &pdev->dev; // Store the device pointer\n    platform_set_drvdata(pdev, priv); // Store private data in platform device\n\n    // Initialize completion variable\n    init_completion(&priv->irq_completion);\n\n    // Initialize simulated register values\n    priv->control_reg_val = 0x0;\n    priv->status_reg_val = 0x0;\n    priv->data_reg_val = 0xDEADBEEF; // Default data value\n\n    // 2. Get and map MMIO resources\n    res_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n    if (!res_mem) {\n        dev_err(&pdev->dev, \"No MMIO resource found.\\n\");\n        return -ENODEV;\n    }\n\n    priv->regs = devm_ioremap_resource(&pdev->dev, res_mem);\n    if (IS_ERR(priv->regs)) {\n        dev_err(&pdev->dev, \"Failed to ioremap MMIO resource.\\n\");\n        return PTR_ERR(priv->regs);\n    }\n    dev_info(&pdev->dev, \"MMIO base mapped at %p, size 0x%lx.\\n\",\n             priv->regs, resource_size(res_mem));\n\n    // 3. Get and request IRQ\n    res_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);\n    if (!res_irq) {\n        dev_err(&pdev->dev, \"No IRQ resource found.\\n\");\n        return -ENODEV;\n    }\n    priv->irq = res_irq->start;\n\n    ret = devm_request_irq(&pdev->dev, priv->irq, my_hw_isr,\n                           IRQF_SHARED, pdev->name, priv); // Use IRQF_SHARED for example\n    if (ret) {\n        dev_err(&pdev->dev, \"Failed to request IRQ %d: %d\\n\", priv->irq, ret);\n        return ret;\n    }\n    dev_info(&pdev->dev, \"IRQ %d requested successfully.\\n\", priv->irq);\n\n    // 4. Register Character Device\n    ret = alloc_chrdev_region(&priv->dev_num, 0, 1, \"my_hw_dev\");\n    if (ret < 0) {\n        dev_err(&pdev->dev, \"Failed to allocate char device region.\\n\");\n        return ret;\n    }\n    dev_info(&pdev->dev, \"Allocated char dev major: %d, minor: %d\\n\",\n             MAJOR(priv->dev_num), MINOR(priv->dev_num));\n\n    cdev_init(&priv->cdev, &my_hw_fops);\n    priv->cdev.owner = THIS_MODULE;\n\n    ret = cdev_add(&priv->cdev, priv->dev_num, 1);\n    if (ret < 0) {\n        dev_err(&pdev->dev, \"Failed to add char device.\\n\");\n        goto err_unregister_chrdev;\n    }\n\n    // 5. Create device file in /dev (udev will create it)\n    priv->dev_class = class_create(THIS_MODULE, \"my_hw_class\");\n    if (IS_ERR(priv->dev_class)) {\n        dev_err(&pdev->dev, \"Failed to create device class.\\n\");\n        ret = PTR_ERR(priv->dev_class);\n        goto err_cdev_del;\n    }\n\n    // This creates the /dev/my_hw_devX entry\n    // It's crucial to pass priv->dev (i.e., &pdev->dev) as parent.\n    // This associates the char device with the platform device.\n    if (IS_ERR(device_create(priv->dev_class, &pdev->dev, priv->dev_num,\n                             NULL, \"my_hw_dev%d\", MINOR(priv->dev_num)))) {\n        dev_err(&pdev->dev, \"Failed to create device node.\\n\");\n        ret = -ENOMEM;\n        goto err_class_destroy;\n    }\n\n    dev_info(&pdev->dev, \"Probe successful. Device /dev/my_hw_dev%d created.\\n\", MINOR(priv->dev_num));\n    return 0; // Success\n\nerr_class_destroy:\n    class_destroy(priv->dev_class);\nerr_cdev_del:\n    cdev_del(&priv->cdev);\nerr_unregister_chrdev:\n    unregister_chrdev_region(priv->dev_num, 1);\n    // devm_ resources are automatically freed on probe exit if return value is error\n    return ret;\n}\n\nstatic int my_hw_remove(struct platform_device *pdev)\n{\n    struct my_hw_dev *priv = platform_get_drvdata(pdev);\n\n    dev_info(&pdev->dev, \"Remove function called for %s.\\n\", pdev->name);\n\n    // 1. Destroy device file\n    device_destroy(priv->dev_class, priv->dev_num);\n\n    // 2. Destroy device class\n    class_destroy(priv->dev_class);\n\n    // 3. Delete character device\n    cdev_del(&priv->cdev);\n\n    // 4. Unregister character device region\n    unregister_chrdev_region(priv->dev_num, 1);\n\n    // devm_ APIs (devm_ioremap_resource, devm_request_irq, devm_kzalloc)\n    // automatically free their resources when the device is unbound (driver is removed).\n    // So no explicit iounmap, free_irq, or kfree is needed here for those.\n\n    dev_info(&pdev->dev, \"Device removed successfully.\\n\");\n    return 0;\n}\n\n// --- Platform Driver Definition ---\n// This tells the kernel what devices this driver supports.\n// For example, it could match based on compatible string from Device Tree.\nstatic const struct of_device_id my_hw_of_match[] = {\n    { .compatible = \"vendor,my-hardware-device\", },\n    { /* sentinel */ }\n};\nMODULE_DEVICE_TABLE(of, my_hw_of_match); // Export this table to userspace\n\nstatic struct platform_driver my_hw_driver = {\n    .probe      = my_hw_probe,\n    .remove     = my_hw_remove,\n    .driver     = {\n        .name   = \"my_hw_driver\",\n        .of_match_table = my_hw_of_match, // Used for Device Tree matching\n    },\n};\n\n// --- Module Initialization and Exit ---\n\n// We will dynamically create a platform device in module_init for demonstration.\n// In a real system, the platform device (or device tree node) would be defined\n// statically by the board file or Device Tree Blob (DTB).\nstatic struct platform_device *my_sim_pdev;\n\nstatic int __init my_hw_init(void)\n{\n    int ret;\n    struct resource my_hw_resources[] = {\n        // Simulated MMIO region\n        {\n            .start = 0x10000000, // Arbitrary base address for simulation\n            .end   = 0x10000000 + 0x100 - 1, // 256 bytes for registers\n            .flags = IORESOURCE_MEM,\n            .name  = \"my_hw_mmio\",\n        },\n        // Simulated IRQ line\n        {\n            .start = 123, // Arbitrary IRQ number for simulation (ensure it's not used by real hardware)\n            .end   = 123,\n            .flags = IORESOURCE_IRQ,\n            .name  = \"my_hw_irq\",\n        },\n    };\n\n    pr_info(\"My Hardware Module: Initializing...\\n\");\n\n    // 1. Allocate a simulated platform device\n    my_sim_pdev = platform_device_alloc(\"my_hw_driver\", PLATFORM_DEVID_NONE);\n    if (!my_sim_pdev) {\n        pr_err(\"Failed to allocate simulated platform device.\\n\");\n        return -ENOMEM;\n    }\n\n    // 2. Add resources to the simulated device\n    ret = platform_device_add_resources(my_sim_pdev, my_hw_resources,\n                                        ARRAY_SIZE(my_hw_resources));\n    if (ret) {\n        pr_err(\"Failed to add resources to simulated platform device: %d\\n\", ret);\n        goto err_device_put;\n    }\n\n    // 3. Set the compatible string for Device Tree matching\n    // This allows our driver's 'of_match_table' to find this simulated device.\n    my_sim_pdev->dev.of_node = of_fwnode_handle_create(&my_sim_pdev->dev,\n                                (void *)my_hw_of_match[0].compatible, NULL,\n                                NULL, NULL, NULL);\n    if (IS_ERR(my_sim_pdev->dev.of_node)) {\n        pr_err(\"Failed to create OF node handle for simulated device.\\n\");\n        ret = PTR_ERR(my_sim_pdev->dev.of_node);\n        goto err_device_put;\n    }\n    pr_info(\"Simulated platform device OF node created with compatible: %s\\n\",\n            my_hw_of_match[0].compatible);\n\n\n    // 4. Add the simulated platform device to the system\n    ret = platform_device_add(my_sim_pdev);\n    if (ret) {\n        pr_err(\"Failed to add simulated platform device: %d\\n\", ret);\n        goto err_of_node_put;\n    }\n    pr_info(\"Simulated platform device added.\\n\");\n\n    // 5. Register our platform driver\n    ret = platform_driver_register(&my_hw_driver);\n    if (ret) {\n        pr_err(\"Failed to register platform driver: %d\\n\", ret);\n        goto err_device_del;\n    }\n\n    pr_info(\"My Hardware Module: Initialized successfully.\\n\");\n    return 0;\n\nerr_device_del:\n    platform_device_del(my_sim_pdev);\nerr_of_node_put:\n    of_fwnode_handle_put(my_sim_pdev->dev.of_node);\nerr_device_put:\n    platform_device_put(my_sim_pdev);\n    return ret;\n}\n\nstatic void __exit my_hw_exit(void)\n{\n    pr_info(\"My Hardware Module: Exiting...\\n\");\n\n    // 1. Unregister our platform driver\n    platform_driver_unregister(&my_hw_driver);\n\n    // 2. Delete the simulated platform device\n    if (my_sim_pdev) {\n        // This will call my_hw_remove as the driver is unbound\n        platform_device_del(my_sim_pdev);\n        of_fwnode_handle_put(my_sim_pdev->dev.of_node);\n        platform_device_put(my_sim_pdev);\n    }\n\n    pr_info(\"My Hardware Module: Exited.\\n\");\n}\n\nmodule_init(my_hw_init);\nmodule_exit(my_hw_exit);\n```\n\n---\n\n**2. `Makefile`**\n\n```makefile\n# If KERNELRELEASE is not defined, we are building against the current kernel\nifeq ($(KERNELRELEASE),)\nKERNELDIR ?= /lib/modules/$(shell uname -r)/build\nPWD := $(shell pwd)\n\nmodules:\n\t$(MAKE) -C $(KERNELDIR) M=$(PWD) modules\n\nmodules_install:\n\t$(MAKE) -C $(KERNELDIR) M=$(PWD) modules_install\n\nclean:\n\t$(MAKE) -C $(KERNELDIR) M=$(PWD) clean\n\trm -f my_hw_app\n\n.PHONY: modules modules_install clean\n\nelse\n# KERNELRELEASE is defined, so we are being built from the kernel build system\nobj-m := my_hw_driver.o\nendif\n```\n\n---\n\n**3. `my_hw_app.c` (User-Space Test Application)**\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <stdint.h> // For u32 (uint32_t)\n\n// IOCTL Commands (must match kernel module)\n#define MY_HW_IOC_MAGIC  'M'\n#define MY_HW_IOC_SET_CONTROL  _IOW(MY_HW_IOC_MAGIC, 1, uint32_t)\n#define MY_HW_IOC_GET_CONTROL  _IOR(MY_HW_IOC_MAGIC, 2, uint32_t)\n#define MY_HW_IOC_GET_STATUS   _IOR(MY_HW_IOC_MAGIC, 3, uint32_t)\n#define MY_HW_IOC_TRIGGER_IRQ  _IO(MY_HW_IOC_MAGIC, 4)\n#define MY_HW_IOC_WAIT_FOR_IRQ _IO(MY_HW_IOC_MAGIC, 5)\n\nint main() {\n    int fd;\n    uint32_t value;\n    ssize_t bytes_read, bytes_written;\n\n    printf(\"Opening /dev/my_hw_dev0...\\n\");\n    fd = open(\"/dev/my_hw_dev0\", O_RDWR);\n    if (fd < 0) {\n        perror(\"Failed to open device /dev/my_hw_dev0\");\n        return 1;\n    }\n    printf(\"Device opened successfully (fd=%d).\\n\", fd);\n\n    // --- Test IOCTLs ---\n\n    // 1. Get initial control register value\n    if (ioctl(fd, MY_HW_IOC_GET_CONTROL, &value) < 0) {\n        perror(\"IOCTL MY_HW_IOC_GET_CONTROL failed\");\n    } else {\n        printf(\"Initial CONTROL_REG: 0x%08X\\n\", value);\n    }\n\n    // 2. Set control register\n    value = 0x12345678;\n    printf(\"Setting CONTROL_REG to 0x%08X...\\n\", value);\n    if (ioctl(fd, MY_HW_IOC_SET_CONTROL, &value) < 0) {\n        perror(\"IOCTL MY_HW_IOC_SET_CONTROL failed\");\n    } else {\n        printf(\"CONTROL_REG set successfully.\\n\");\n    }\n\n    // 3. Get updated control register value\n    if (ioctl(fd, MY_HW_IOC_GET_CONTROL, &value) < 0) {\n        perror(\"IOCTL MY_HW_IOC_GET_CONTROL failed\");\n    } else {\n        printf(\"Updated CONTROL_REG: 0x%08X\\n\", value);\n    }\n\n    // 4. Get status register\n    if (ioctl(fd, MY_HW_IOC_GET_STATUS, &value) < 0) {\n        perror(\"IOCTL MY_HW_IOC_GET_STATUS failed\");\n    } else {\n        printf(\"STATUS_REG: 0x%08X\\n\", value);\n    }\n\n    // --- Test Read/Write (DATA_REG) ---\n\n    // 1. Write to DATA_REG\n    value = 0xAABBCCDD;\n    printf(\"Writing 0x%08X to DATA_REG via write()...\\n\", value);\n    bytes_written = write(fd, &value, sizeof(value));\n    if (bytes_written < 0) {\n        perror(\"Write to device failed\");\n    } else {\n        printf(\"Wrote %zd bytes.\\n\", bytes_written);\n    }\n\n    // 2. Read from DATA_REG\n    value = 0; // Clear before read\n    printf(\"Reading from DATA_REG via read()...\\n\");\n    bytes_read = read(fd, &value, sizeof(value));\n    if (bytes_read < 0) {\n        perror(\"Read from device failed\");\n    } else {\n        printf(\"Read %zd bytes, DATA_REG: 0x%08X\\n\", bytes_read, value);\n    }\n\n    // --- Test Interrupt Simulation ---\n\n    // Trigger IRQ in background (or a separate process/thread)\n    printf(\"Triggering simulated IRQ...\\n\");\n    if (ioctl(fd, MY_HW_IOC_TRIGGER_IRQ) < 0) {\n        perror(\"IOCTL MY_HW_IOC_TRIGGER_IRQ failed\");\n    } else {\n        printf(\"Simulated IRQ triggered.\\n\");\n    }\n\n    // Wait for IRQ\n    printf(\"Waiting for IRQ event (this will block until triggered)...\\n\");\n    if (ioctl(fd, MY_HW_IOC_WAIT_FOR_IRQ) < 0) {\n        perror(\"IOCTL MY_HW_IOC_WAIT_FOR_IRQ failed\");\n    } else {\n        printf(\"IRQ event received!\\n\");\n    }\n    \n    // Demonstrate waiting for IRQ again after another trigger\n    printf(\"\\nTriggering and waiting for IRQ again...\\n\");\n    if (ioctl(fd, MY_HW_IOC_TRIGGER_IRQ) < 0) {\n        perror(\"IOCTL MY_HW_IOC_TRIGGER_IRQ failed (2nd time)\");\n    } else {\n        printf(\"Simulated IRQ triggered (2nd time).\\n\");\n    }\n    if (ioctl(fd, MY_HW_IOC_WAIT_FOR_IRQ) < 0) {\n        perror(\"IOCTL MY_HW_IOC_WAIT_FOR_IRQ failed (2nd time)\");\n    } else {\n        printf(\"IRQ event received (2nd time)!\\n\");\n    }\n\n\n    printf(\"Closing device.\\n\");\n    close(fd);\n\n    return 0;\n}\n```\n\n---\n\n**Building and Testing:**\n\n1.  **Save the files:**\n    *   `my_hw_driver.c`\n    *   `Makefile`\n    *   `my_hw_app.c`\n\n2.  **Compile the kernel module:**\n    ```bash\n    make\n    ```\n\n3.  **Compile the user-space application:**\n    ```bash\n    gcc -o my_hw_app my_hw_app.c\n    ```\n\n4.  **Load the module (requires root privileges):**\n    ```bash\n    sudo insmod my_hw_driver.ko\n    ```\n    *   Check `dmesg` output: You should see messages about the module initializing, the simulated platform device being added, MMIO mapping, and IRQ requested. You should also see `/dev/my_hw_dev0` created.\n\n5.  **Run the user-space application:**\n    ```bash\n    ./my_hw_app\n    ```\n    *   Observe the output from both the application and `dmesg`. You'll see the read/write operations and the interrupt simulation working.\n\n6.  **Unload the module:**\n    ```bash\n    sudo rmmod my_hw_driver\n    ```\n    *   Check `dmesg` again; the `remove` function should be called, and resources cleaned up.\n\n**Explanation of the Simulation:**\n\n*   **Platform Device (`my_sim_pdev`):** Instead of relying on a real Device Tree or board file, we dynamically create a `platform_device` in `module_init`. This device is given simulated MMIO and IRQ resources. The `platform_driver_register` then causes our `my_hw_probe` function to be called, just as if a real hardware device was discovered.\n*   **MMIO Registers (`priv->regs`):** We use `devm_ioremap_resource` to get a kernel virtual address for the \"hardware\" registers. However, since there's no physical hardware at `0x10000000`, `ioread32` and `iowrite32` would operate on unallocated memory. To work around this for a *pure simulation*, we maintain `control_reg_val`, `data_reg_val`, `status_reg_val` fields within our `my_hw_dev` structure. Reads/writes to MMIO are simulated by accessing these members. This is a common pattern for *purely software-simulated* hardware within a driver for testing or conceptual demonstration. For a real device, you would *only* use `ioread32`/`iowrite32` to the `priv->regs` pointer.\n*   **Interrupt (`my_hw_isr` and `completion`):**\n    *   The `my_hw_isr` is registered with the kernel's IRQ subsystem.\n    *   For the simulation, when user-space sends the `MY_HW_IOC_TRIGGER_IRQ` ioctl, the driver *directly calls* `my_hw_isr(priv->irq, priv)`. This bypasses actual hardware signal generation but still executes the ISR's logic.\n    *   The ISR then calls `complete(&priv->irq_completion)`.\n    *   User-space, having called `MY_HW_IOC_WAIT_FOR_IRQ`, will be blocked in `wait_for_completion_interruptible` until `complete` is called by the ISR. This demonstrates the typical producer-consumer pattern for interrupt handling."
        }
    }
}